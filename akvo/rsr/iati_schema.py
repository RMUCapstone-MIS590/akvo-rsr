#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Thu Mar 13 10:45:54 2014 by generateDS.py version 2.12b.
#

import sys
import getopt
import re as re_
import base64
import datetime as datetime_

etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class iati_activities(GeneratedsSuper):
    """Top-level list of one or more IATI activity records. A number
    indicating the IATI specification version in use. A date/time
    stamp for when this file was generated. This is not necessarily
    the last-updated date for the individual activity records in it.
    Uses ISO 8601 date format, e.g. "2010-03-12T18:45:00+01:00". Use
    of this attribute is highly recommended, to allow recipients to
    know when a file has been updated. IATI publishers are not
    obliged to publish their own Linked Data. However, if a
    publisher chooses to publish linked data about their IATI
    activities then allowing them to declare where this data is
    published would support discovery of it, and any additional
    information they may choose to publish as Linked Data alongside
    it. This attribute is URI path upon which an activity identifier
    can be appended to get a dereferenceable URI for any activity
    contained within a file. Where a publisher declares using one of
    these properties that authoritative linked data is accessible
    for an activity then consuming applications that are generating
    Linked Data from an IATI XML file should assert an owl:sameAs
    relationship to the relevant URI."""
    subclass = None
    superclass = None
    def __init__(self, generated_datetime=None, version=None, linked_data_default=None, iati_activity=None, anytypeobjs_=None):
        if isinstance(generated_datetime, basestring):
            initvalue_ = datetime_.datetime.strptime(generated_datetime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = generated_datetime
        self.generated_datetime = initvalue_
        self.version = _cast(float, version)
        self.linked_data_default = _cast(None, linked_data_default)
        if iati_activity is None:
            self.iati_activity = []
        else:
            self.iati_activity = iati_activity
        self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if iati_activities.subclass:
            return iati_activities.subclass(*args_, **kwargs_)
        else:
            return iati_activities(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_iati_activity(self): return self.iati_activity
    def set_iati_activity(self, iati_activity): self.iati_activity = iati_activity
    def add_iati_activity(self, value): self.iati_activity.append(value)
    def insert_iati_activity(self, index, value): self.iati_activity[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_generated_datetime(self): return self.generated_datetime
    def set_generated_datetime(self, generated_datetime): self.generated_datetime = generated_datetime
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_linked_data_default(self): return self.linked_data_default
    def set_linked_data_default(self, linked_data_default): self.linked_data_default = linked_data_default
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.iati_activity or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='iati-activities', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='iati-activities')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='iati-activities', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='iati-activities'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.generated_datetime is not None and 'generated_datetime' not in already_processed:
            already_processed.add('generated_datetime')
            outfile.write(' generated-datetime="%s"' % self.gds_format_datetime(self.generated_datetime, input_name='generated-datetime'))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version="%s"' % self.gds_format_float(self.version, input_name='version'))
        if self.linked_data_default is not None and 'linked_data_default' not in already_processed:
            already_processed.add('linked_data_default')
            outfile.write(' linked-data-default=%s' % (self.gds_format_string(quote_attrib(self.linked_data_default).encode(ExternalEncoding), input_name='linked-data-default'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='iati-activities', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for iati_activity_ in self.iati_activity:
            iati_activity_.export(outfile, level, namespace_, name_='iati-activity', pretty_print=pretty_print)
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='iati-activities'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.generated_datetime is not None and 'generated_datetime' not in already_processed:
            already_processed.add('generated_datetime')
            showIndent(outfile, level)
            outfile.write('generated-datetime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.generated_datetime, input_name='generated-datetime'))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version=%f,\n' % (self.version,))
        if self.linked_data_default is not None and 'linked_data_default' not in already_processed:
            already_processed.add('linked_data_default')
            showIndent(outfile, level)
            outfile.write('linked_data_default="%s",\n' % (self.linked_data_default,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('iati_activity=[\n')
        level += 1
        for iati_activity_ in self.iati_activity:
            showIndent(outfile, level)
            outfile.write('model_.iati_activity(\n')
            iati_activity_.exportLiteral(outfile, level, name_='iati-activity')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('generated-datetime', node)
        if value is not None and 'generated-datetime' not in already_processed:
            already_processed.add('generated-datetime')
            try:
                self.generated_datetime = self.gds_parse_datetime(value)
            except ValueError, exp:
                raise ValueError('Bad date-time attribute (generated-datetime): %s' % exp)
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            try:
                self.version = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (version): %s' % exp)
        value = find_attr_value_('linked-data-default', node)
        if value is not None and 'linked-data-default' not in already_processed:
            already_processed.add('linked-data-default')
            self.linked_data_default = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'iati-activity':
            obj_ = iati_activity.factory()
            obj_.build(child_)
            self.iati_activity.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'iati-activities')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class iati_activities


class iati_activity(GeneratedsSuper):
    """Top-level element for a single IATI activity report. A number
    indicating the IATI specification version in use. Defaults to
    "1.0" if not specified. It is required to specify this attribute
    if the document is using features specific to an IATI
    specification other than the initial 1.0 version. The last
    date/time that the data for this specific activity was updated.
    This date must change whenever the value of any field changes.
    Default ISO 4217 currency code for all financial values in this
    activity report. See http://iatistandard.org/codelists/currency
    The hierarchical level within the reporting organisation's
    subdivision of its units of aid. (eg activity = 1; sub-activity
    = 2; sub-sub-activity = 3). If hierarchy is not reported then 1
    is assumed. If multiple levels are reported then, to avoid
    double counting, financial transactions should only be reported
    at the lowest hierarchical level. A Linked Data URI for a given
    activity (overrides iati-activities/@linked-data-default if set)"""
    subclass = None
    superclass = None
    def __init__(self, lang=None, linked_data_uri=None, hierarchy=None, default_currency=None, last_updated_datetime=None, version=None, activity_website=None, reporting_org=None, participating_org=None, activity_scope=None, recipient_country=None, recipient_region=None, collaboration_type=None, default_flow_type=None, default_aid_type=None, default_finance_type=None, iati_identifier=None, other_identifier=None, title=None, description=None, sector=None, activity_date=None, activity_status=None, contact_info=None, default_tied_status=None, policy_marker=None, location=None, capital_spend=None, transaction=None, result=None, conditions=None, budget=None, planned_disbursement=None, country_budget_items=None, related_activity=None, document_link=None, legacy_data=None, crs_add=None, fss=None, anytypeobjs_=None):
        self.lang = _cast(None, lang)
        self.linked_data_uri = _cast(None, linked_data_uri)
        self.hierarchy = _cast(int, hierarchy)
        self.default_currency = _cast(None, default_currency)
        if isinstance(last_updated_datetime, basestring):
            initvalue_ = datetime_.datetime.strptime(last_updated_datetime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = last_updated_datetime
        self.last_updated_datetime = initvalue_
        self.version = _cast(float, version)
        if activity_website is None:
            self.activity_website = []
        else:
            self.activity_website = activity_website
        if reporting_org is None:
            self.reporting_org = []
        else:
            self.reporting_org = reporting_org
        if participating_org is None:
            self.participating_org = []
        else:
            self.participating_org = participating_org
        if activity_scope is None:
            self.activity_scope = []
        else:
            self.activity_scope = activity_scope
        if recipient_country is None:
            self.recipient_country = []
        else:
            self.recipient_country = recipient_country
        if recipient_region is None:
            self.recipient_region = []
        else:
            self.recipient_region = recipient_region
        if collaboration_type is None:
            self.collaboration_type = []
        else:
            self.collaboration_type = collaboration_type
        if default_flow_type is None:
            self.default_flow_type = []
        else:
            self.default_flow_type = default_flow_type
        if default_aid_type is None:
            self.default_aid_type = []
        else:
            self.default_aid_type = default_aid_type
        if default_finance_type is None:
            self.default_finance_type = []
        else:
            self.default_finance_type = default_finance_type
        if iati_identifier is None:
            self.iati_identifier = []
        else:
            self.iati_identifier = iati_identifier
        if other_identifier is None:
            self.other_identifier = []
        else:
            self.other_identifier = other_identifier
        if title is None:
            self.title = []
        else:
            self.title = title
        if description is None:
            self.description = []
        else:
            self.description = description
        if sector is None:
            self.sector = []
        else:
            self.sector = sector
        if activity_date is None:
            self.activity_date = []
        else:
            self.activity_date = activity_date
        if activity_status is None:
            self.activity_status = []
        else:
            self.activity_status = activity_status
        if contact_info is None:
            self.contact_info = []
        else:
            self.contact_info = contact_info
        if default_tied_status is None:
            self.default_tied_status = []
        else:
            self.default_tied_status = default_tied_status
        if policy_marker is None:
            self.policy_marker = []
        else:
            self.policy_marker = policy_marker
        if location is None:
            self.location = []
        else:
            self.location = location
        if capital_spend is None:
            self.capital_spend = []
        else:
            self.capital_spend = capital_spend
        if transaction is None:
            self.transaction = []
        else:
            self.transaction = transaction
        if result is None:
            self.result = []
        else:
            self.result = result
        if conditions is None:
            self.conditions = []
        else:
            self.conditions = conditions
        if budget is None:
            self.budget = []
        else:
            self.budget = budget
        if planned_disbursement is None:
            self.planned_disbursement = []
        else:
            self.planned_disbursement = planned_disbursement
        if country_budget_items is None:
            self.country_budget_items = []
        else:
            self.country_budget_items = country_budget_items
        if related_activity is None:
            self.related_activity = []
        else:
            self.related_activity = related_activity
        if document_link is None:
            self.document_link = []
        else:
            self.document_link = document_link
        if legacy_data is None:
            self.legacy_data = []
        else:
            self.legacy_data = legacy_data
        if crs_add is None:
            self.crs_add = []
        else:
            self.crs_add = crs_add
        if fss is None:
            self.fss = []
        else:
            self.fss = fss
        self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if iati_activity.subclass:
            return iati_activity.subclass(*args_, **kwargs_)
        else:
            return iati_activity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_activity_website(self): return self.activity_website
    def set_activity_website(self, activity_website): self.activity_website = activity_website
    def add_activity_website(self, value): self.activity_website.append(value)
    def insert_activity_website(self, index, value): self.activity_website[index] = value
    def get_reporting_org(self): return self.reporting_org
    def set_reporting_org(self, reporting_org): self.reporting_org = reporting_org
    def add_reporting_org(self, value): self.reporting_org.append(value)
    def insert_reporting_org(self, index, value): self.reporting_org[index] = value
    def get_participating_org(self): return self.participating_org
    def set_participating_org(self, participating_org): self.participating_org = participating_org
    def add_participating_org(self, value): self.participating_org.append(value)
    def insert_participating_org(self, index, value): self.participating_org[index] = value
    def get_activity_scope(self): return self.activity_scope
    def set_activity_scope(self, activity_scope): self.activity_scope = activity_scope
    def add_activity_scope(self, value): self.activity_scope.append(value)
    def insert_activity_scope(self, index, value): self.activity_scope[index] = value
    def get_recipient_country(self): return self.recipient_country
    def set_recipient_country(self, recipient_country): self.recipient_country = recipient_country
    def add_recipient_country(self, value): self.recipient_country.append(value)
    def insert_recipient_country(self, index, value): self.recipient_country[index] = value
    def get_recipient_region(self): return self.recipient_region
    def set_recipient_region(self, recipient_region): self.recipient_region = recipient_region
    def add_recipient_region(self, value): self.recipient_region.append(value)
    def insert_recipient_region(self, index, value): self.recipient_region[index] = value
    def get_collaboration_type(self): return self.collaboration_type
    def set_collaboration_type(self, collaboration_type): self.collaboration_type = collaboration_type
    def add_collaboration_type(self, value): self.collaboration_type.append(value)
    def insert_collaboration_type(self, index, value): self.collaboration_type[index] = value
    def get_default_flow_type(self): return self.default_flow_type
    def set_default_flow_type(self, default_flow_type): self.default_flow_type = default_flow_type
    def add_default_flow_type(self, value): self.default_flow_type.append(value)
    def insert_default_flow_type(self, index, value): self.default_flow_type[index] = value
    def get_default_aid_type(self): return self.default_aid_type
    def set_default_aid_type(self, default_aid_type): self.default_aid_type = default_aid_type
    def add_default_aid_type(self, value): self.default_aid_type.append(value)
    def insert_default_aid_type(self, index, value): self.default_aid_type[index] = value
    def get_default_finance_type(self): return self.default_finance_type
    def set_default_finance_type(self, default_finance_type): self.default_finance_type = default_finance_type
    def add_default_finance_type(self, value): self.default_finance_type.append(value)
    def insert_default_finance_type(self, index, value): self.default_finance_type[index] = value
    def get_iati_identifier(self): return self.iati_identifier
    def set_iati_identifier(self, iati_identifier): self.iati_identifier = iati_identifier
    def add_iati_identifier(self, value): self.iati_identifier.append(value)
    def insert_iati_identifier(self, index, value): self.iati_identifier[index] = value
    def get_other_identifier(self): return self.other_identifier
    def set_other_identifier(self, other_identifier): self.other_identifier = other_identifier
    def add_other_identifier(self, value): self.other_identifier.append(value)
    def insert_other_identifier(self, index, value): self.other_identifier[index] = value
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def add_title(self, value): self.title.append(value)
    def insert_title(self, index, value): self.title[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def add_description(self, value): self.description.append(value)
    def insert_description(self, index, value): self.description[index] = value
    def get_sector(self): return self.sector
    def set_sector(self, sector): self.sector = sector
    def add_sector(self, value): self.sector.append(value)
    def insert_sector(self, index, value): self.sector[index] = value
    def get_activity_date(self): return self.activity_date
    def set_activity_date(self, activity_date): self.activity_date = activity_date
    def add_activity_date(self, value): self.activity_date.append(value)
    def insert_activity_date(self, index, value): self.activity_date[index] = value
    def get_activity_status(self): return self.activity_status
    def set_activity_status(self, activity_status): self.activity_status = activity_status
    def add_activity_status(self, value): self.activity_status.append(value)
    def insert_activity_status(self, index, value): self.activity_status[index] = value
    def get_contact_info(self): return self.contact_info
    def set_contact_info(self, contact_info): self.contact_info = contact_info
    def add_contact_info(self, value): self.contact_info.append(value)
    def insert_contact_info(self, index, value): self.contact_info[index] = value
    def get_default_tied_status(self): return self.default_tied_status
    def set_default_tied_status(self, default_tied_status): self.default_tied_status = default_tied_status
    def add_default_tied_status(self, value): self.default_tied_status.append(value)
    def insert_default_tied_status(self, index, value): self.default_tied_status[index] = value
    def get_policy_marker(self): return self.policy_marker
    def set_policy_marker(self, policy_marker): self.policy_marker = policy_marker
    def add_policy_marker(self, value): self.policy_marker.append(value)
    def insert_policy_marker(self, index, value): self.policy_marker[index] = value
    def get_location(self): return self.location
    def set_location(self, location): self.location = location
    def add_location(self, value): self.location.append(value)
    def insert_location(self, index, value): self.location[index] = value
    def get_capital_spend(self): return self.capital_spend
    def set_capital_spend(self, capital_spend): self.capital_spend = capital_spend
    def add_capital_spend(self, value): self.capital_spend.append(value)
    def insert_capital_spend(self, index, value): self.capital_spend[index] = value
    def get_transaction(self): return self.transaction
    def set_transaction(self, transaction): self.transaction = transaction
    def add_transaction(self, value): self.transaction.append(value)
    def insert_transaction(self, index, value): self.transaction[index] = value
    def get_result(self): return self.result
    def set_result(self, result): self.result = result
    def add_result(self, value): self.result.append(value)
    def insert_result(self, index, value): self.result[index] = value
    def get_conditions(self): return self.conditions
    def set_conditions(self, conditions): self.conditions = conditions
    def add_conditions(self, value): self.conditions.append(value)
    def insert_conditions(self, index, value): self.conditions[index] = value
    def get_budget(self): return self.budget
    def set_budget(self, budget): self.budget = budget
    def add_budget(self, value): self.budget.append(value)
    def insert_budget(self, index, value): self.budget[index] = value
    def get_planned_disbursement(self): return self.planned_disbursement
    def set_planned_disbursement(self, planned_disbursement): self.planned_disbursement = planned_disbursement
    def add_planned_disbursement(self, value): self.planned_disbursement.append(value)
    def insert_planned_disbursement(self, index, value): self.planned_disbursement[index] = value
    def get_country_budget_items(self): return self.country_budget_items
    def set_country_budget_items(self, country_budget_items): self.country_budget_items = country_budget_items
    def add_country_budget_items(self, value): self.country_budget_items.append(value)
    def insert_country_budget_items(self, index, value): self.country_budget_items[index] = value
    def get_related_activity(self): return self.related_activity
    def set_related_activity(self, related_activity): self.related_activity = related_activity
    def add_related_activity(self, value): self.related_activity.append(value)
    def insert_related_activity(self, index, value): self.related_activity[index] = value
    def get_document_link(self): return self.document_link
    def set_document_link(self, document_link): self.document_link = document_link
    def add_document_link(self, value): self.document_link.append(value)
    def insert_document_link(self, index, value): self.document_link[index] = value
    def get_legacy_data(self): return self.legacy_data
    def set_legacy_data(self, legacy_data): self.legacy_data = legacy_data
    def add_legacy_data(self, value): self.legacy_data.append(value)
    def insert_legacy_data(self, index, value): self.legacy_data[index] = value
    def get_crs_add(self): return self.crs_add
    def set_crs_add(self, crs_add): self.crs_add = crs_add
    def add_crs_add(self, value): self.crs_add.append(value)
    def insert_crs_add(self, index, value): self.crs_add[index] = value
    def get_fss(self): return self.fss
    def set_fss(self, fss): self.fss = fss
    def add_fss(self, value): self.fss.append(value)
    def insert_fss(self, index, value): self.fss[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_linked_data_uri(self): return self.linked_data_uri
    def set_linked_data_uri(self, linked_data_uri): self.linked_data_uri = linked_data_uri
    def get_hierarchy(self): return self.hierarchy
    def set_hierarchy(self, hierarchy): self.hierarchy = hierarchy
    def get_default_currency(self): return self.default_currency
    def set_default_currency(self, default_currency): self.default_currency = default_currency
    def get_last_updated_datetime(self): return self.last_updated_datetime
    def set_last_updated_datetime(self, last_updated_datetime): self.last_updated_datetime = last_updated_datetime
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.activity_website or
            self.reporting_org or
            self.participating_org or
            self.activity_scope or
            self.recipient_country or
            self.recipient_region or
            self.collaboration_type or
            self.default_flow_type or
            self.default_aid_type or
            self.default_finance_type or
            self.iati_identifier or
            self.other_identifier or
            self.title or
            self.description or
            self.sector or
            self.activity_date or
            self.activity_status or
            self.contact_info or
            self.default_tied_status or
            self.policy_marker or
            self.location or
            self.capital_spend or
            self.transaction or
            self.result or
            self.conditions or
            self.budget or
            self.planned_disbursement or
            self.country_budget_items or
            self.related_activity or
            self.document_link or
            self.legacy_data or
            self.crs_add or
            self.fss or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='iati-activity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='iati-activity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='iati-activity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='iati-activity'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.linked_data_uri is not None and 'linked_data_uri' not in already_processed:
            already_processed.add('linked_data_uri')
            outfile.write(' linked-data-uri=%s' % (self.gds_format_string(quote_attrib(self.linked_data_uri).encode(ExternalEncoding), input_name='linked-data-uri'), ))
        if self.hierarchy is not None and 'hierarchy' not in already_processed:
            already_processed.add('hierarchy')
            outfile.write(' hierarchy="%s"' % self.gds_format_integer(self.hierarchy, input_name='hierarchy'))
        if self.default_currency is not None and 'default_currency' not in already_processed:
            already_processed.add('default_currency')
            outfile.write(' default-currency=%s' % (self.gds_format_string(quote_attrib(self.default_currency).encode(ExternalEncoding), input_name='default-currency'), ))
        if self.last_updated_datetime is not None and 'last_updated_datetime' not in already_processed:
            already_processed.add('last_updated_datetime')
            outfile.write(' last-updated-datetime="%s"' % self.gds_format_datetime(self.last_updated_datetime, input_name='last-updated-datetime'))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version="%s"' % self.gds_format_float(self.version, input_name='version'))
    def exportChildren(self, outfile, level, namespace_='', name_='iati-activity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for activity_website_ in self.activity_website:
            activity_website_.export(outfile, level, namespace_, name_='activity-website', pretty_print=pretty_print)
        for reporting_org_ in self.reporting_org:
            reporting_org_.export(outfile, level, namespace_, name_='reporting-org', pretty_print=pretty_print)
        for participating_org_ in self.participating_org:
            participating_org_.export(outfile, level, namespace_, name_='participating-org', pretty_print=pretty_print)
        for activity_scope_ in self.activity_scope:
            activity_scope_.export(outfile, level, namespace_, name_='activity-scope', pretty_print=pretty_print)
        for recipient_country_ in self.recipient_country:
            recipient_country_.export(outfile, level, namespace_, name_='recipient-country', pretty_print=pretty_print)
        for recipient_region_ in self.recipient_region:
            recipient_region_.export(outfile, level, namespace_, name_='recipient-region', pretty_print=pretty_print)
        for collaboration_type_ in self.collaboration_type:
            collaboration_type_.export(outfile, level, namespace_, name_='collaboration-type', pretty_print=pretty_print)
        for default_flow_type_ in self.default_flow_type:
            default_flow_type_.export(outfile, level, namespace_, name_='default-flow-type', pretty_print=pretty_print)
        for default_aid_type_ in self.default_aid_type:
            default_aid_type_.export(outfile, level, namespace_, name_='default-aid-type', pretty_print=pretty_print)
        for default_finance_type_ in self.default_finance_type:
            default_finance_type_.export(outfile, level, namespace_, name_='default-finance-type', pretty_print=pretty_print)
        for iati_identifier_ in self.iati_identifier:
            iati_identifier_.export(outfile, level, namespace_, name_='iati-identifier', pretty_print=pretty_print)
        for other_identifier_ in self.other_identifier:
            other_identifier_.export(outfile, level, namespace_, name_='other-identifier', pretty_print=pretty_print)
        for title_ in self.title:
            title_.export(outfile, level, namespace_, name_='title', pretty_print=pretty_print)
        for description_ in self.description:
            description_.export(outfile, level, namespace_, name_='description', pretty_print=pretty_print)
        for sector_ in self.sector:
            sector_.export(outfile, level, namespace_, name_='sector', pretty_print=pretty_print)
        for activity_date_ in self.activity_date:
            activity_date_.export(outfile, level, namespace_, name_='activity-date', pretty_print=pretty_print)
        for activity_status_ in self.activity_status:
            activity_status_.export(outfile, level, namespace_, name_='activity-status', pretty_print=pretty_print)
        for contact_info_ in self.contact_info:
            contact_info_.export(outfile, level, namespace_, name_='contact-info', pretty_print=pretty_print)
        for default_tied_status_ in self.default_tied_status:
            default_tied_status_.export(outfile, level, namespace_, name_='default-tied-status', pretty_print=pretty_print)
        for policy_marker_ in self.policy_marker:
            policy_marker_.export(outfile, level, namespace_, name_='policy-marker', pretty_print=pretty_print)
        for location_ in self.location:
            location_.export(outfile, level, namespace_, name_='location', pretty_print=pretty_print)
        for capital_spend_ in self.capital_spend:
            capital_spend_.export(outfile, level, namespace_, name_='capital-spend', pretty_print=pretty_print)
        for transaction_ in self.transaction:
            transaction_.export(outfile, level, namespace_, name_='transaction', pretty_print=pretty_print)
        for result_ in self.result:
            result_.export(outfile, level, namespace_, name_='result', pretty_print=pretty_print)
        for conditions_ in self.conditions:
            conditions_.export(outfile, level, namespace_, name_='conditions', pretty_print=pretty_print)
        for budget_ in self.budget:
            budget_.export(outfile, level, namespace_, name_='budget', pretty_print=pretty_print)
        for planned_disbursement_ in self.planned_disbursement:
            planned_disbursement_.export(outfile, level, namespace_, name_='planned-disbursement', pretty_print=pretty_print)
        for country_budget_items_ in self.country_budget_items:
            country_budget_items_.export(outfile, level, namespace_, name_='country-budget-items', pretty_print=pretty_print)
        for related_activity_ in self.related_activity:
            related_activity_.export(outfile, level, namespace_, name_='related-activity', pretty_print=pretty_print)
        for document_link_ in self.document_link:
            document_link_.export(outfile, level, namespace_, name_='document-link', pretty_print=pretty_print)
        for legacy_data_ in self.legacy_data:
            legacy_data_.export(outfile, level, namespace_, name_='legacy-data', pretty_print=pretty_print)
        for crs_add_ in self.crs_add:
            crs_add_.export(outfile, level, namespace_, name_='crs-add', pretty_print=pretty_print)
        for fss_ in self.fss:
            fss_.export(outfile, level, namespace_, name_='fss', pretty_print=pretty_print)
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='iati-activity'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('xml:lang="%s",\n' % (self.lang,))
        if self.linked_data_uri is not None and 'linked_data_uri' not in already_processed:
            already_processed.add('linked_data_uri')
            showIndent(outfile, level)
            outfile.write('linked_data_uri="%s",\n' % (self.linked_data_uri,))
        if self.hierarchy is not None and 'hierarchy' not in already_processed:
            already_processed.add('hierarchy')
            showIndent(outfile, level)
            outfile.write('hierarchy=%d,\n' % (self.hierarchy,))
        if self.default_currency is not None and 'default_currency' not in already_processed:
            already_processed.add('default_currency')
            showIndent(outfile, level)
            outfile.write('default_currency="%s",\n' % (self.default_currency,))
        if self.last_updated_datetime is not None and 'last_updated_datetime' not in already_processed:
            already_processed.add('last_updated_datetime')
            showIndent(outfile, level)
            outfile.write('last-updated-datetime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.last_updated_datetime, input_name='last-updated-datetime'))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version=%f,\n' % (self.version,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('activity_website=[\n')
        level += 1
        for activity_website_ in self.activity_website:
            showIndent(outfile, level)
            outfile.write('model_.activity_website(\n')
            activity_website_.exportLiteral(outfile, level, name_='activity-website')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('reporting_org=[\n')
        level += 1
        for reporting_org_ in self.reporting_org:
            showIndent(outfile, level)
            outfile.write('model_.reporting_org(\n')
            reporting_org_.exportLiteral(outfile, level, name_='reporting-org')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('participating_org=[\n')
        level += 1
        for participating_org_ in self.participating_org:
            showIndent(outfile, level)
            outfile.write('model_.participating_org(\n')
            participating_org_.exportLiteral(outfile, level, name_='participating-org')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('activity_scope=[\n')
        level += 1
        for activity_scope_ in self.activity_scope:
            showIndent(outfile, level)
            outfile.write('model_.activity_scope(\n')
            activity_scope_.exportLiteral(outfile, level, name_='activity-scope')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('recipient_country=[\n')
        level += 1
        for recipient_country_ in self.recipient_country:
            showIndent(outfile, level)
            outfile.write('model_.recipient_country(\n')
            recipient_country_.exportLiteral(outfile, level, name_='recipient-country')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('recipient_region=[\n')
        level += 1
        for recipient_region_ in self.recipient_region:
            showIndent(outfile, level)
            outfile.write('model_.recipient_region(\n')
            recipient_region_.exportLiteral(outfile, level, name_='recipient-region')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('collaboration_type=[\n')
        level += 1
        for collaboration_type_ in self.collaboration_type:
            showIndent(outfile, level)
            outfile.write('model_.collaboration_type(\n')
            collaboration_type_.exportLiteral(outfile, level, name_='collaboration-type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('default_flow_type=[\n')
        level += 1
        for default_flow_type_ in self.default_flow_type:
            showIndent(outfile, level)
            outfile.write('model_.default_flow_type(\n')
            default_flow_type_.exportLiteral(outfile, level, name_='default-flow-type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('default_aid_type=[\n')
        level += 1
        for default_aid_type_ in self.default_aid_type:
            showIndent(outfile, level)
            outfile.write('model_.default_aid_type(\n')
            default_aid_type_.exportLiteral(outfile, level, name_='default-aid-type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('default_finance_type=[\n')
        level += 1
        for default_finance_type_ in self.default_finance_type:
            showIndent(outfile, level)
            outfile.write('model_.default_finance_type(\n')
            default_finance_type_.exportLiteral(outfile, level, name_='default-finance-type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('iati_identifier=[\n')
        level += 1
        for iati_identifier_ in self.iati_identifier:
            showIndent(outfile, level)
            outfile.write('model_.iati_identifier(\n')
            iati_identifier_.exportLiteral(outfile, level, name_='iati-identifier')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('other_identifier=[\n')
        level += 1
        for other_identifier_ in self.other_identifier:
            showIndent(outfile, level)
            outfile.write('model_.other_identifier(\n')
            other_identifier_.exportLiteral(outfile, level, name_='other-identifier')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('title=[\n')
        level += 1
        for title_ in self.title:
            showIndent(outfile, level)
            outfile.write('model_.title(\n')
            title_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('description=[\n')
        level += 1
        for description_ in self.description:
            showIndent(outfile, level)
            outfile.write('model_.description(\n')
            description_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('sector=[\n')
        level += 1
        for sector_ in self.sector:
            showIndent(outfile, level)
            outfile.write('model_.sector(\n')
            sector_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('activity_date=[\n')
        level += 1
        for activity_date_ in self.activity_date:
            showIndent(outfile, level)
            outfile.write('model_.activity_date(\n')
            activity_date_.exportLiteral(outfile, level, name_='activity-date')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('activity_status=[\n')
        level += 1
        for activity_status_ in self.activity_status:
            showIndent(outfile, level)
            outfile.write('model_.activity_status(\n')
            activity_status_.exportLiteral(outfile, level, name_='activity-status')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('contact_info=[\n')
        level += 1
        for contact_info_ in self.contact_info:
            showIndent(outfile, level)
            outfile.write('model_.contact_info(\n')
            contact_info_.exportLiteral(outfile, level, name_='contact-info')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('default_tied_status=[\n')
        level += 1
        for default_tied_status_ in self.default_tied_status:
            showIndent(outfile, level)
            outfile.write('model_.default_tied_status(\n')
            default_tied_status_.exportLiteral(outfile, level, name_='default-tied-status')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('policy_marker=[\n')
        level += 1
        for policy_marker_ in self.policy_marker:
            showIndent(outfile, level)
            outfile.write('model_.policy_marker(\n')
            policy_marker_.exportLiteral(outfile, level, name_='policy-marker')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('location=[\n')
        level += 1
        for location_ in self.location:
            showIndent(outfile, level)
            outfile.write('model_.location(\n')
            location_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('capital_spend=[\n')
        level += 1
        for capital_spend_ in self.capital_spend:
            showIndent(outfile, level)
            outfile.write('model_.capital_spend(\n')
            capital_spend_.exportLiteral(outfile, level, name_='capital-spend')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('transaction=[\n')
        level += 1
        for transaction_ in self.transaction:
            showIndent(outfile, level)
            outfile.write('model_.transaction(\n')
            transaction_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('result=[\n')
        level += 1
        for result_ in self.result:
            showIndent(outfile, level)
            outfile.write('model_.result(\n')
            result_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('conditions=[\n')
        level += 1
        for conditions_ in self.conditions:
            showIndent(outfile, level)
            outfile.write('model_.conditions(\n')
            conditions_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('budget=[\n')
        level += 1
        for budget_ in self.budget:
            showIndent(outfile, level)
            outfile.write('model_.budget(\n')
            budget_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('planned_disbursement=[\n')
        level += 1
        for planned_disbursement_ in self.planned_disbursement:
            showIndent(outfile, level)
            outfile.write('model_.planned_disbursement(\n')
            planned_disbursement_.exportLiteral(outfile, level, name_='planned-disbursement')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('country_budget_items=[\n')
        level += 1
        for country_budget_items_ in self.country_budget_items:
            showIndent(outfile, level)
            outfile.write('model_.country_budget_items(\n')
            country_budget_items_.exportLiteral(outfile, level, name_='country-budget-items')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('related_activity=[\n')
        level += 1
        for related_activity_ in self.related_activity:
            showIndent(outfile, level)
            outfile.write('model_.related_activity(\n')
            related_activity_.exportLiteral(outfile, level, name_='related-activity')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('document_link=[\n')
        level += 1
        for document_link_ in self.document_link:
            showIndent(outfile, level)
            outfile.write('model_.document_link(\n')
            document_link_.exportLiteral(outfile, level, name_='document-link')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('legacy_data=[\n')
        level += 1
        for legacy_data_ in self.legacy_data:
            showIndent(outfile, level)
            outfile.write('model_.legacy_data(\n')
            legacy_data_.exportLiteral(outfile, level, name_='legacy-data')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('crs_add=[\n')
        level += 1
        for crs_add_ in self.crs_add:
            showIndent(outfile, level)
            outfile.write('model_.crs_add(\n')
            crs_add_.exportLiteral(outfile, level, name_='crs-add')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('fss=[\n')
        level += 1
        for fss_ in self.fss:
            showIndent(outfile, level)
            outfile.write('model_.fss(\n')
            fss_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('linked-data-uri', node)
        if value is not None and 'linked-data-uri' not in already_processed:
            already_processed.add('linked-data-uri')
            self.linked_data_uri = value
        value = find_attr_value_('hierarchy', node)
        if value is not None and 'hierarchy' not in already_processed:
            already_processed.add('hierarchy')
            try:
                self.hierarchy = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('default-currency', node)
        if value is not None and 'default-currency' not in already_processed:
            already_processed.add('default-currency')
            self.default_currency = value
        value = find_attr_value_('last-updated-datetime', node)
        if value is not None and 'last-updated-datetime' not in already_processed:
            already_processed.add('last-updated-datetime')
            try:
                self.last_updated_datetime = self.gds_parse_datetime(value)
            except ValueError, exp:
                raise ValueError('Bad date-time attribute (last-updated-datetime): %s' % exp)
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            try:
                self.version = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (version): %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'activity-website':
            obj_ = activity_website.factory()
            obj_.build(child_)
            self.activity_website.append(obj_)
        elif nodeName_ == 'reporting-org':
            obj_ = reporting_org.factory()
            obj_.build(child_)
            self.reporting_org.append(obj_)
        elif nodeName_ == 'participating-org':
            obj_ = participating_org.factory()
            obj_.build(child_)
            self.participating_org.append(obj_)
        elif nodeName_ == 'activity-scope':
            obj_ = codeType.factory()
            obj_.build(child_)
            self.activity_scope.append(obj_)
        elif nodeName_ == 'recipient-country':
            obj_ = recipient_country.factory()
            obj_.build(child_)
            self.recipient_country.append(obj_)
        elif nodeName_ == 'recipient-region':
            obj_ = recipient_region.factory()
            obj_.build(child_)
            self.recipient_region.append(obj_)
        elif nodeName_ == 'collaboration-type':
            obj_ = codeReqType.factory()
            obj_.build(child_)
            self.collaboration_type.append(obj_)
        elif nodeName_ == 'default-flow-type':
            obj_ = codeReqType.factory()
            obj_.build(child_)
            self.default_flow_type.append(obj_)
        elif nodeName_ == 'default-aid-type':
            obj_ = codeReqType.factory()
            obj_.build(child_)
            self.default_aid_type.append(obj_)
        elif nodeName_ == 'default-finance-type':
            obj_ = codeReqType.factory()
            obj_.build(child_)
            self.default_finance_type.append(obj_)
        elif nodeName_ == 'iati-identifier':
            obj_ = iati_identifier.factory()
            obj_.build(child_)
            self.iati_identifier.append(obj_)
        elif nodeName_ == 'other-identifier':
            obj_ = other_identifier.factory()
            obj_.build(child_)
            self.other_identifier.append(obj_)
        elif nodeName_ == 'title':
            obj_ = textType.factory()
            obj_.build(child_)
            self.title.append(obj_)
        elif nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.description.append(obj_)
        elif nodeName_ == 'sector':
            obj_ = sector.factory()
            obj_.build(child_)
            self.sector.append(obj_)
        elif nodeName_ == 'activity-date':
            obj_ = activity_date.factory()
            obj_.build(child_)
            self.activity_date.append(obj_)
        elif nodeName_ == 'activity-status':
            obj_ = codeType.factory()
            obj_.build(child_)
            self.activity_status.append(obj_)
        elif nodeName_ == 'contact-info':
            obj_ = contact_info.factory()
            obj_.build(child_)
            self.contact_info.append(obj_)
        elif nodeName_ == 'default-tied-status':
            obj_ = codeReqType.factory()
            obj_.build(child_)
            self.default_tied_status.append(obj_)
        elif nodeName_ == 'policy-marker':
            obj_ = policy_marker.factory()
            obj_.build(child_)
            self.policy_marker.append(obj_)
        elif nodeName_ == 'location':
            obj_ = location.factory()
            obj_.build(child_)
            self.location.append(obj_)
        elif nodeName_ == 'capital-spend':
            obj_ = capital_spend.factory()
            obj_.build(child_)
            self.capital_spend.append(obj_)
        elif nodeName_ == 'transaction':
            obj_ = transaction.factory()
            obj_.build(child_)
            self.transaction.append(obj_)
        elif nodeName_ == 'result':
            obj_ = result.factory()
            obj_.build(child_)
            self.result.append(obj_)
        elif nodeName_ == 'conditions':
            obj_ = conditions.factory()
            obj_.build(child_)
            self.conditions.append(obj_)
        elif nodeName_ == 'budget':
            obj_ = budget.factory()
            obj_.build(child_)
            self.budget.append(obj_)
        elif nodeName_ == 'planned-disbursement':
            obj_ = planned_disbursement.factory()
            obj_.build(child_)
            self.planned_disbursement.append(obj_)
        elif nodeName_ == 'country-budget-items':
            obj_ = country_budget_items.factory()
            obj_.build(child_)
            self.country_budget_items.append(obj_)
        elif nodeName_ == 'related-activity':
            obj_ = related_activity.factory()
            obj_.build(child_)
            self.related_activity.append(obj_)
        elif nodeName_ == 'document-link':
            obj_ = document_link.factory()
            obj_.build(child_)
            self.document_link.append(obj_)
        elif nodeName_ == 'legacy-data':
            obj_ = legacy_data.factory()
            obj_.build(child_)
            self.legacy_data.append(obj_)
        elif nodeName_ == 'crs-add':
            obj_ = crs_add.factory()
            obj_.build(child_)
            self.crs_add.append(obj_)
        elif nodeName_ == 'fss':
            obj_ = fss.factory()
            obj_.build(child_)
            self.fss.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'iati-activity')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class iati_activity


class activity_website(GeneratedsSuper):
    """A link to a web site providing more information about the aid
    activity. Multiple versions of the link may appear for different
    languages."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if activity_website.subclass:
            return activity_website.subclass(*args_, **kwargs_)
        else:
            return activity_website(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='activity-website', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='activity-website')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='activity-website', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='activity-website'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='activity-website', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='activity-website'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class activity_website


class participating_org(GeneratedsSuper):
    """An organisation (including the reporting organisation) involved with
    the activity. May be a donor, fund, agency, etc. Specifying the
    @identifier and @role attributes is strongly recommended. May
    contain the organisation name as content. For the value of the
    @type attribute, see http://iatistandard.org/codelists
    /organisation-type For the value of the @ref attribute, see the
    list of officially-registered organizations at
    http://iatistandard.org/codelists/organisation A code describing
    the organisation's role in the activity (donor, agency, etc.).
    See http://iatistandard.org/codelists/organisation_role"""
    subclass = None
    superclass = None
    def __init__(self, lang=None, type_=None, role=None, ref=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.lang = _cast(None, lang)
        self.type_ = _cast(None, type_)
        self.role = _cast(None, role)
        self.ref = _cast(None, ref)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if participating_org.subclass:
            return participating_org.subclass(*args_, **kwargs_)
        else:
            return participating_org(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='participating-org', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='participating-org')
        if self.hasContent_():
            outfile.write('>')
            self.exportLiteral(outfile, level)
            #showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='participating-org'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='participating-org', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='participating-org'):
        #level += 1
        #already_processed = set()
        #self.exportLiteralAttributes(outfile, level, already_processed, name_)
        #if self.hasContent_():
        #    self.exportLiteralChildren(outfile, level, name_)
        #showIndent(outfile, level)
        outfile.write('%s' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.role is not None and 'role' not in already_processed:
            already_processed.add('role')
            showIndent(outfile, level)
            outfile.write('role="%s",\n' % (self.role,))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            showIndent(outfile, level)
            outfile.write('ref="%s",\n' % (self.ref,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.add('role')
            self.role = value
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class participating_org


class recipient_country(GeneratedsSuper):
    """A partner country that will benefit from this activity. This element
    is primarily for administrative and geopolitical purposes. If a
    specific country is not known, the activity report can use the
    recipient-region element instead. For geographical location, use
    the location element. For the value of the @code attribute, see
    http://iatistandard.org/codelists/country"""
    subclass = None
    superclass = None
    def __init__(self, lang=None, percentage=None, code=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.lang = _cast(None, lang)
        self.percentage = _cast(None, percentage)
        self.code = _cast(None, code)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if recipient_country.subclass:
            return recipient_country.subclass(*args_, **kwargs_)
        else:
            return recipient_country(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_percentage(self): return self.percentage
    def set_percentage(self, percentage): self.percentage = percentage
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='recipient-country', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='recipient-country')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='recipient-country', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='recipient-country'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.percentage is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            outfile.write(' percentage=%s' % (self.gds_format_string(quote_attrib(self.percentage).encode(ExternalEncoding), input_name='percentage'), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='recipient-country', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='recipient-country'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        if self.percentage is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            showIndent(outfile, level)
            outfile.write('percentage="%s",\n' % (self.percentage,))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('percentage', node)
        if value is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            self.percentage = value
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class recipient_country


class recipient_region(GeneratedsSuper):
    """A geopolitical region (above the country level) that will benefit
    from this activity. This element is primarily for administrative
    and geopolitical purposes. If the specific country/-ies are
    known, the activity report can use the recipient-country element
    instead. For geographical location, use the location element.
    For the value of the @code attribute, see
    http://iatistandard.org/codelists/region The vocabulary from
    which the region code is drawn. If it is not present 1 - 'OECD
    DAC' is assumed."""
    subclass = None
    superclass = None
    def __init__(self, lang=None, percentage=None, code=None, vocabulary=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.lang = _cast(None, lang)
        self.percentage = _cast(None, percentage)
        self.code = _cast(None, code)
        self.vocabulary = _cast(None, vocabulary)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if recipient_region.subclass:
            return recipient_region.subclass(*args_, **kwargs_)
        else:
            return recipient_region(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_percentage(self): return self.percentage
    def set_percentage(self, percentage): self.percentage = percentage
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_vocabulary(self): return self.vocabulary
    def set_vocabulary(self, vocabulary): self.vocabulary = vocabulary
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='recipient-region', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='recipient-region')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='recipient-region', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='recipient-region'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.percentage is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            outfile.write(' percentage=%s' % (self.gds_format_string(quote_attrib(self.percentage).encode(ExternalEncoding), input_name='percentage'), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
        if self.vocabulary is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            outfile.write(' vocabulary=%s' % (self.gds_format_string(quote_attrib(self.vocabulary).encode(ExternalEncoding), input_name='vocabulary'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='recipient-region', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='recipient-region'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        if self.percentage is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            showIndent(outfile, level)
            outfile.write('percentage="%s",\n' % (self.percentage,))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        if self.vocabulary is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            showIndent(outfile, level)
            outfile.write('vocabulary="%s",\n' % (self.vocabulary,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('percentage', node)
        if value is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            self.percentage = value
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        value = find_attr_value_('vocabulary', node)
        if value is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            self.vocabulary = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class recipient_region


class other_identifier(GeneratedsSuper):
    """An alternative, non-IATI identifier for the activity. This
    identifier is not guaranteed to be unique or persistent (it
    depends on the owner organisation's policies, not IATI's). If
    other-identifier is present then either @owner-ref or @owner-
    name must be present An identifier for the owner of this
    identifier, in URI format. See the list of officially-registered
    organizations at http://iatistandard.org/codelists/organisation
    Free text providing a human-readable name for the owner of this
    identifier."""
    subclass = None
    superclass = None
    def __init__(self, owner_ref=None, owner_name=None, valueOf_=None, mixedclass_=None, content_=None):
        self.owner_ref = _cast(None, owner_ref)
        self.owner_name = _cast(None, owner_name)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if other_identifier.subclass:
            return other_identifier.subclass(*args_, **kwargs_)
        else:
            return other_identifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_owner_ref(self): return self.owner_ref
    def set_owner_ref(self, owner_ref): self.owner_ref = owner_ref
    def get_owner_name(self): return self.owner_name
    def set_owner_name(self, owner_name): self.owner_name = owner_name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='other-identifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='other-identifier')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='other-identifier'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.owner_ref is not None and 'owner_ref' not in already_processed:
            already_processed.add('owner_ref')
            outfile.write(' owner-ref=%s' % (self.gds_format_string(quote_attrib(self.owner_ref).encode(ExternalEncoding), input_name='owner-ref'), ))
        if self.owner_name is not None and 'owner_name' not in already_processed:
            already_processed.add('owner_name')
            outfile.write(' owner-name=%s' % (self.gds_format_string(quote_attrib(self.owner_name).encode(ExternalEncoding), input_name='owner-name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='other-identifier', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='other-identifier'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.owner_ref is not None and 'owner_ref' not in already_processed:
            already_processed.add('owner_ref')
            showIndent(outfile, level)
            outfile.write('owner_ref="%s",\n' % (self.owner_ref,))
        if self.owner_name is not None and 'owner_name' not in already_processed:
            already_processed.add('owner_name')
            showIndent(outfile, level)
            outfile.write('owner_name="%s",\n' % (self.owner_name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('owner-ref', node)
        if value is not None and 'owner-ref' not in already_processed:
            already_processed.add('owner-ref')
            self.owner_ref = value
        value = find_attr_value_('owner-name', node)
        if value is not None and 'owner-name' not in already_processed:
            already_processed.add('owner-name')
            self.owner_name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class other_identifier


class sector(GeneratedsSuper):
    """Sector code and name. For the value of the @code attribute, see
    http://iatistandard.org/codelists/sector Either the @code
    attribute or descriptive text content must be present. The code
    for the sector. If the vocabulary is "DAC" or missing then the
    CRS Sector Code should be used. Code is not mandatory but highly
    recommended. Either code or description must be present. The
    vocabulary (codelist) used for sector classifications. If
    omitted, assume DAC. "DAC" codes should be used wherever
    possible. It is also recommended that if a publisher has its own
    classification system then the vocabulary "RO" (Reporting
    Organisation's own vocabulary" should be used in addition to
    "DAC". NB that if multiple sector codes are used in multiple
    vocabularies then each vocabulary's percentages should add up to
    100%. See http://iatistandard.org/codelists/vocabulary"""
    subclass = None
    superclass = None
    def __init__(self, lang=None, percentage=None, code=None, vocabulary=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.lang = _cast(None, lang)
        self.percentage = _cast(None, percentage)
        self.code = _cast(None, code)
        self.vocabulary = _cast(None, vocabulary)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if sector.subclass:
            return sector.subclass(*args_, **kwargs_)
        else:
            return sector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_percentage(self): return self.percentage
    def set_percentage(self, percentage): self.percentage = percentage
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_vocabulary(self): return self.vocabulary
    def set_vocabulary(self, vocabulary): self.vocabulary = vocabulary
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='sector', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sector')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='sector', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='sector'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.percentage is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            outfile.write(' percentage=%s' % (self.gds_format_string(quote_attrib(self.percentage).encode(ExternalEncoding), input_name='percentage'), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
        if self.vocabulary is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            outfile.write(' vocabulary=%s' % (self.gds_format_string(quote_attrib(self.vocabulary).encode(ExternalEncoding), input_name='vocabulary'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='sector', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='sector'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        if self.percentage is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            showIndent(outfile, level)
            outfile.write('percentage="%s",\n' % (self.percentage,))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        if self.vocabulary is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            showIndent(outfile, level)
            outfile.write('vocabulary="%s",\n' % (self.vocabulary,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('percentage', node)
        if value is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            self.percentage = value
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        value = find_attr_value_('vocabulary', node)
        if value is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            self.vocabulary = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class sector


class activity_date(GeneratedsSuper):
    """The planned and actual start and completion dates of the activity.
    Start dates may reflect either the commencement of funding,
    planning or physical activity. End dates should, wherever
    possible, reflect the ending of physical activity. Dates should
    be in ISO 8601 date YYYY-MM-DD format, e.g. 2010-10-01. For the
    value of the @type attribute, see
    http://iatistandard.org/codelists/activity_date_type The text
    content may contain a general date text (e.g. 2011Q1) for
    recording less specific dates such as month, quarter, or year.
    An activity milestone date in ISO 8601 date format, e.g.
    "2010-12-01"."""
    subclass = None
    superclass = None
    def __init__(self, lang=None, iso_date=None, type_=None, valueOf_=None):
        self.lang = _cast(None, lang)
        if isinstance(iso_date, basestring):
            initvalue_ = datetime_.datetime.strptime(iso_date, '%Y-%m-%d').date()
        else:
            initvalue_ = iso_date
        self.iso_date = initvalue_
        self.type_ = _cast(None, type_)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if activity_date.subclass:
            return activity_date.subclass(*args_, **kwargs_)
        else:
            return activity_date(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_iso_date(self): return self.iso_date
    def set_iso_date(self, iso_date): self.iso_date = iso_date
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='activity-date', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='activity-date')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='activity-date', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='activity-date'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            outfile.write(' iso-date="%s"' % self.gds_format_date(self.iso_date, input_name='iso-date'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='activity-date', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='activity-date'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            showIndent(outfile, level)
            outfile.write('iso-date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.iso_date, input_name='iso-date'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('iso-date', node)
        if value is not None and 'iso-date' not in already_processed:
            already_processed.add('iso-date')
            try:
                self.iso_date = self.gds_parse_date(value)
            except ValueError, exp:
                raise ValueError('Bad date attribute (iso-date): %s' % exp)
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class activity_date


class contact_info(GeneratedsSuper):
    """Contact information for the project. Specify whatever is available.
    You may repeat this element for each contact person."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, organisation=None, person_name=None, job_title=None, telephone=None, email=None, mailing_address=None, website=None, anytypeobjs_=None):
        self.type_ = _cast(None, type_)
        if organisation is None:
            self.organisation = []
        else:
            self.organisation = organisation
        if person_name is None:
            self.person_name = []
        else:
            self.person_name = person_name
        if job_title is None:
            self.job_title = []
        else:
            self.job_title = job_title
        if telephone is None:
            self.telephone = []
        else:
            self.telephone = telephone
        if email is None:
            self.email = []
        else:
            self.email = email
        if mailing_address is None:
            self.mailing_address = []
        else:
            self.mailing_address = mailing_address
        if website is None:
            self.website = []
        else:
            self.website = website
        self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if contact_info.subclass:
            return contact_info.subclass(*args_, **kwargs_)
        else:
            return contact_info(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_organisation(self): return self.organisation
    def set_organisation(self, organisation): self.organisation = organisation
    def add_organisation(self, value): self.organisation.append(value)
    def insert_organisation(self, index, value): self.organisation[index] = value
    def get_person_name(self): return self.person_name
    def set_person_name(self, person_name): self.person_name = person_name
    def add_person_name(self, value): self.person_name.append(value)
    def insert_person_name(self, index, value): self.person_name[index] = value
    def get_job_title(self): return self.job_title
    def set_job_title(self, job_title): self.job_title = job_title
    def add_job_title(self, value): self.job_title.append(value)
    def insert_job_title(self, index, value): self.job_title[index] = value
    def get_telephone(self): return self.telephone
    def set_telephone(self, telephone): self.telephone = telephone
    def add_telephone(self, value): self.telephone.append(value)
    def insert_telephone(self, index, value): self.telephone[index] = value
    def get_email(self): return self.email
    def set_email(self, email): self.email = email
    def add_email(self, value): self.email.append(value)
    def insert_email(self, index, value): self.email[index] = value
    def get_mailing_address(self): return self.mailing_address
    def set_mailing_address(self, mailing_address): self.mailing_address = mailing_address
    def add_mailing_address(self, value): self.mailing_address.append(value)
    def insert_mailing_address(self, index, value): self.mailing_address[index] = value
    def get_website(self): return self.website
    def set_website(self, website): self.website = website
    def add_website(self, value): self.website.append(value)
    def insert_website(self, index, value): self.website[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.organisation or
            self.person_name or
            self.job_title or
            self.telephone or
            self.email or
            self.mailing_address or
            self.website or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='contact-info', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='contact-info')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='contact-info', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='contact-info'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='contact-info', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for organisation_ in self.organisation:
            organisation_.export(outfile, level, namespace_, name_='organisation', pretty_print=pretty_print)
        for person_name_ in self.person_name:
            person_name_.export(outfile, level, namespace_, name_='person-name', pretty_print=pretty_print)
        for job_title_ in self.job_title:
            job_title_.export(outfile, level, namespace_, name_='job-title', pretty_print=pretty_print)
        for telephone_ in self.telephone:
            telephone_.export(outfile, level, namespace_, name_='telephone', pretty_print=pretty_print)
        for email_ in self.email:
            email_.export(outfile, level, namespace_, name_='email', pretty_print=pretty_print)
        for mailing_address_ in self.mailing_address:
            mailing_address_.export(outfile, level, namespace_, name_='mailing-address', pretty_print=pretty_print)
        for website_ in self.website:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swebsite>%s</%swebsite>%s' % (namespace_, self.gds_format_string(quote_xml(website_).encode(ExternalEncoding), input_name='website'), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='contact-info'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('organisation=[\n')
        level += 1
        for organisation_ in self.organisation:
            showIndent(outfile, level)
            outfile.write('model_.textType(\n')
            organisation_.exportLiteral(outfile, level, name_='textType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('person_name=[\n')
        level += 1
        for person_name_ in self.person_name:
            showIndent(outfile, level)
            outfile.write('model_.textType(\n')
            person_name_.exportLiteral(outfile, level, name_='textType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('job_title=[\n')
        level += 1
        for job_title_ in self.job_title:
            showIndent(outfile, level)
            outfile.write('model_.textType(\n')
            job_title_.exportLiteral(outfile, level, name_='textType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('telephone=[\n')
        level += 1
        for telephone_ in self.telephone:
            showIndent(outfile, level)
            outfile.write('model_.telephoneType(\n')
            telephone_.exportLiteral(outfile, level, name_='telephoneType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('email=[\n')
        level += 1
        for email_ in self.email:
            showIndent(outfile, level)
            outfile.write('model_.plainType(\n')
            email_.exportLiteral(outfile, level, name_='plainType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('mailing_address=[\n')
        level += 1
        for mailing_address_ in self.mailing_address:
            showIndent(outfile, level)
            outfile.write('model_.mailing_addressType(\n')
            mailing_address_.exportLiteral(outfile, level, name_='mailing-addressType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('website=[\n')
        level += 1
        for website_ in self.website:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(website_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'organisation':
            obj_ = textType.factory()
            obj_.build(child_)
            self.organisation.append(obj_)
        elif nodeName_ == 'person-name':
            obj_ = textType.factory()
            obj_.build(child_)
            self.person_name.append(obj_)
        elif nodeName_ == 'job-title':
            obj_ = textType.factory()
            obj_.build(child_)
            self.job_title.append(obj_)
        elif nodeName_ == 'telephone':
            obj_ = telephoneType.factory()
            obj_.build(child_)
            self.telephone.append(obj_)
        elif nodeName_ == 'email':
            obj_ = plainType.factory()
            obj_.build(child_)
            self.email.append(obj_)
        elif nodeName_ == 'mailing-address':
            obj_ = mailing_addressType.factory()
            obj_.build(child_)
            self.mailing_address.append(obj_)
        elif nodeName_ == 'website':
            website_ = child_.text
            website_ = self.gds_validate_string(website_, node, 'website')
            self.website.append(website_)
        else:
            obj_ = self.gds_build_any(child_, 'contact-info')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class contact_info


class policy_marker(GeneratedsSuper):
    """A policy or theme addressed by the activity. A text description of
    the theme appears in the content, and a formal identifier
    appears in the @ref attribute. The @vocabulary attribute can
    also help to segment the markers into separate vocabularies.
    This element can be repeated for each policy marker. For the
    value of the @code attribute, see
    http://iatistandard.org/codelists/policy_marker Policy marker
    code. If vocabulary is missing or "DAC" use the IATI Policy
    Marker Code list which is based on columns 20-23 and 28-31 of
    the CRS++ reporting format. Policy vocabulary used. Default is
    "DAC", but "RO" may also be used for publisher's own markers.
    See http://iatistandard.org/codelists/vocabulary The
    significance of the policy marker for this activity (e.g.
    principal or significant), from a list defined by IATI. If a
    marker is not significant, the policy-marker element will not be
    present. See
    http://iatistandard.org/codelists/policy_significance"""
    subclass = None
    superclass = None
    def __init__(self, lang=None, code=None, vocabulary=None, significance=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.lang = _cast(None, lang)
        self.code = _cast(None, code)
        self.vocabulary = _cast(None, vocabulary)
        self.significance = _cast(None, significance)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if policy_marker.subclass:
            return policy_marker.subclass(*args_, **kwargs_)
        else:
            return policy_marker(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_vocabulary(self): return self.vocabulary
    def set_vocabulary(self, vocabulary): self.vocabulary = vocabulary
    def get_significance(self): return self.significance
    def set_significance(self, significance): self.significance = significance
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='policy-marker', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='policy-marker')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='policy-marker', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='policy-marker'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
        if self.vocabulary is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            outfile.write(' vocabulary=%s' % (self.gds_format_string(quote_attrib(self.vocabulary).encode(ExternalEncoding), input_name='vocabulary'), ))
        if self.significance is not None and 'significance' not in already_processed:
            already_processed.add('significance')
            outfile.write(' significance=%s' % (self.gds_format_string(quote_attrib(self.significance).encode(ExternalEncoding), input_name='significance'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='policy-marker', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='policy-marker'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        if self.vocabulary is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            showIndent(outfile, level)
            outfile.write('vocabulary="%s",\n' % (self.vocabulary,))
        if self.significance is not None and 'significance' not in already_processed:
            already_processed.add('significance')
            showIndent(outfile, level)
            outfile.write('significance="%s",\n' % (self.significance,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        value = find_attr_value_('vocabulary', node)
        if value is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            self.vocabulary = value
        value = find_attr_value_('significance', node)
        if value is not None and 'significance' not in already_processed:
            already_processed.add('significance')
            self.significance = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class policy_marker


class capital_spend(GeneratedsSuper):
    """The percentage of the total commitment that is for capital spending"""
    subclass = None
    superclass = None
    def __init__(self, percentage=None, anytypeobjs_=None):
        self.percentage = _cast(None, percentage)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if capital_spend.subclass:
            return capital_spend.subclass(*args_, **kwargs_)
        else:
            return capital_spend(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_percentage(self): return self.percentage
    def set_percentage(self, percentage): self.percentage = percentage
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='capital-spend', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='capital-spend')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='capital-spend', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='capital-spend'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.percentage is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            outfile.write(' percentage=%s' % (self.gds_format_string(quote_attrib(self.percentage).encode(ExternalEncoding), input_name='percentage'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='capital-spend', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='capital-spend'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.percentage is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            showIndent(outfile, level)
            outfile.write('percentage="%s",\n' % (self.percentage,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('percentage', node)
        if value is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            self.percentage = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'capital-spend')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class capital_spend


class transaction(GeneratedsSuper):
    """Committed or actual money flowing in or out of an aid activity.The
    @ref attribute allows uniquely identifying a transaction, to
    match it up with the corresponding in- or outflow in a different
    activity."""
    subclass = None
    superclass = None
    def __init__(self, ref=None, value=None, description=None, transaction_type=None, provider_org=None, receiver_org=None, transaction_date=None, flow_type=None, aid_type=None, finance_type=None, tied_status=None, disbursement_channel=None, anytypeobjs_=None):
        self.ref = _cast(None, ref)
        if value is None:
            self.value = []
        else:
            self.value = value
        if description is None:
            self.description = []
        else:
            self.description = description
        if transaction_type is None:
            self.transaction_type = []
        else:
            self.transaction_type = transaction_type
        if provider_org is None:
            self.provider_org = []
        else:
            self.provider_org = provider_org
        if receiver_org is None:
            self.receiver_org = []
        else:
            self.receiver_org = receiver_org
        if transaction_date is None:
            self.transaction_date = []
        else:
            self.transaction_date = transaction_date
        if flow_type is None:
            self.flow_type = []
        else:
            self.flow_type = flow_type
        if aid_type is None:
            self.aid_type = []
        else:
            self.aid_type = aid_type
        if finance_type is None:
            self.finance_type = []
        else:
            self.finance_type = finance_type
        if tied_status is None:
            self.tied_status = []
        else:
            self.tied_status = tied_status
        if disbursement_channel is None:
            self.disbursement_channel = []
        else:
            self.disbursement_channel = disbursement_channel
        self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if transaction.subclass:
            return transaction.subclass(*args_, **kwargs_)
        else:
            return transaction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def add_description(self, value): self.description.append(value)
    def insert_description(self, index, value): self.description[index] = value
    def get_transaction_type(self): return self.transaction_type
    def set_transaction_type(self, transaction_type): self.transaction_type = transaction_type
    def add_transaction_type(self, value): self.transaction_type.append(value)
    def insert_transaction_type(self, index, value): self.transaction_type[index] = value
    def get_provider_org(self): return self.provider_org
    def set_provider_org(self, provider_org): self.provider_org = provider_org
    def add_provider_org(self, value): self.provider_org.append(value)
    def insert_provider_org(self, index, value): self.provider_org[index] = value
    def get_receiver_org(self): return self.receiver_org
    def set_receiver_org(self, receiver_org): self.receiver_org = receiver_org
    def add_receiver_org(self, value): self.receiver_org.append(value)
    def insert_receiver_org(self, index, value): self.receiver_org[index] = value
    def get_transaction_date(self): return self.transaction_date
    def set_transaction_date(self, transaction_date): self.transaction_date = transaction_date
    def add_transaction_date(self, value): self.transaction_date.append(value)
    def insert_transaction_date(self, index, value): self.transaction_date[index] = value
    def get_flow_type(self): return self.flow_type
    def set_flow_type(self, flow_type): self.flow_type = flow_type
    def add_flow_type(self, value): self.flow_type.append(value)
    def insert_flow_type(self, index, value): self.flow_type[index] = value
    def get_aid_type(self): return self.aid_type
    def set_aid_type(self, aid_type): self.aid_type = aid_type
    def add_aid_type(self, value): self.aid_type.append(value)
    def insert_aid_type(self, index, value): self.aid_type[index] = value
    def get_finance_type(self): return self.finance_type
    def set_finance_type(self, finance_type): self.finance_type = finance_type
    def add_finance_type(self, value): self.finance_type.append(value)
    def insert_finance_type(self, index, value): self.finance_type[index] = value
    def get_tied_status(self): return self.tied_status
    def set_tied_status(self, tied_status): self.tied_status = tied_status
    def add_tied_status(self, value): self.tied_status.append(value)
    def insert_tied_status(self, index, value): self.tied_status[index] = value
    def get_disbursement_channel(self): return self.disbursement_channel
    def set_disbursement_channel(self, disbursement_channel): self.disbursement_channel = disbursement_channel
    def add_disbursement_channel(self, value): self.disbursement_channel.append(value)
    def insert_disbursement_channel(self, index, value): self.disbursement_channel[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.value or
            self.description or
            self.transaction_type or
            self.provider_org or
            self.receiver_org or
            self.transaction_date or
            self.flow_type or
            self.aid_type or
            self.finance_type or
            self.tied_status or
            self.disbursement_channel or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='transaction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='transaction')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='transaction', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='transaction'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='transaction', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for value_ in self.value:
            value_.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
        for description_ in self.description:
            description_.export(outfile, level, namespace_, name_='description', pretty_print=pretty_print)
        for transaction_type_ in self.transaction_type:
            transaction_type_.export(outfile, level, namespace_, name_='transaction-type', pretty_print=pretty_print)
        for provider_org_ in self.provider_org:
            provider_org_.export(outfile, level, namespace_, name_='provider-org', pretty_print=pretty_print)
        for receiver_org_ in self.receiver_org:
            receiver_org_.export(outfile, level, namespace_, name_='receiver-org', pretty_print=pretty_print)
        for transaction_date_ in self.transaction_date:
            transaction_date_.export(outfile, level, namespace_, name_='transaction-date', pretty_print=pretty_print)
        for flow_type_ in self.flow_type:
            flow_type_.export(outfile, level, namespace_, name_='flow-type', pretty_print=pretty_print)
        for aid_type_ in self.aid_type:
            aid_type_.export(outfile, level, namespace_, name_='aid-type', pretty_print=pretty_print)
        for finance_type_ in self.finance_type:
            finance_type_.export(outfile, level, namespace_, name_='finance-type', pretty_print=pretty_print)
        for tied_status_ in self.tied_status:
            tied_status_.export(outfile, level, namespace_, name_='tied-status', pretty_print=pretty_print)
        for disbursement_channel_ in self.disbursement_channel:
            disbursement_channel_.export(outfile, level, namespace_, name_='disbursement-channel', pretty_print=pretty_print)
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='transaction'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            showIndent(outfile, level)
            outfile.write('ref="%s",\n' % (self.ref,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('model_.currencyType(\n')
            value_.exportLiteral(outfile, level, name_='currencyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('description=[\n')
        level += 1
        for description_ in self.description:
            showIndent(outfile, level)
            outfile.write('model_.textType(\n')
            description_.exportLiteral(outfile, level, name_='textType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('transaction_type=[\n')
        level += 1
        for transaction_type_ in self.transaction_type:
            showIndent(outfile, level)
            outfile.write('model_.codeReqType(\n')
            transaction_type_.exportLiteral(outfile, level, name_='codeReqType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('provider_org=[\n')
        level += 1
        for provider_org_ in self.provider_org:
            showIndent(outfile, level)
            outfile.write('model_.provider_orgType(\n')
            provider_org_.exportLiteral(outfile, level, name_='provider-orgType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('receiver_org=[\n')
        level += 1
        for receiver_org_ in self.receiver_org:
            showIndent(outfile, level)
            outfile.write('model_.receiver_orgType(\n')
            receiver_org_.exportLiteral(outfile, level, name_='receiver-orgType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('transaction_date=[\n')
        level += 1
        for transaction_date_ in self.transaction_date:
            showIndent(outfile, level)
            outfile.write('model_.transaction_dateType(\n')
            transaction_date_.exportLiteral(outfile, level, name_='transaction-dateType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('flow_type=[\n')
        level += 1
        for flow_type_ in self.flow_type:
            showIndent(outfile, level)
            outfile.write('model_.codeReqType(\n')
            flow_type_.exportLiteral(outfile, level, name_='codeReqType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('aid_type=[\n')
        level += 1
        for aid_type_ in self.aid_type:
            showIndent(outfile, level)
            outfile.write('model_.codeReqType(\n')
            aid_type_.exportLiteral(outfile, level, name_='codeReqType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('finance_type=[\n')
        level += 1
        for finance_type_ in self.finance_type:
            showIndent(outfile, level)
            outfile.write('model_.codeReqType(\n')
            finance_type_.exportLiteral(outfile, level, name_='codeReqType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('tied_status=[\n')
        level += 1
        for tied_status_ in self.tied_status:
            showIndent(outfile, level)
            outfile.write('model_.codeReqType(\n')
            tied_status_.exportLiteral(outfile, level, name_='codeReqType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('disbursement_channel=[\n')
        level += 1
        for disbursement_channel_ in self.disbursement_channel:
            showIndent(outfile, level)
            outfile.write('model_.codeReqType(\n')
            disbursement_channel_.exportLiteral(outfile, level, name_='codeReqType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            obj_ = currencyType.factory()
            obj_.build(child_)
            self.value.append(obj_)
        elif nodeName_ == 'description':
            obj_ = textType.factory()
            obj_.build(child_)
            self.description.append(obj_)
        elif nodeName_ == 'transaction-type':
            obj_ = codeReqType.factory()
            obj_.build(child_)
            self.transaction_type.append(obj_)
        elif nodeName_ == 'provider-org':
            obj_ = provider_orgType.factory()
            obj_.build(child_)
            self.provider_org.append(obj_)
        elif nodeName_ == 'receiver-org':
            obj_ = receiver_orgType.factory()
            obj_.build(child_)
            self.receiver_org.append(obj_)
        elif nodeName_ == 'transaction-date':
            obj_ = transaction_dateType.factory()
            obj_.build(child_)
            self.transaction_date.append(obj_)
        elif nodeName_ == 'flow-type':
            obj_ = codeReqType.factory()
            obj_.build(child_)
            self.flow_type.append(obj_)
        elif nodeName_ == 'aid-type':
            obj_ = codeReqType.factory()
            obj_.build(child_)
            self.aid_type.append(obj_)
        elif nodeName_ == 'finance-type':
            obj_ = codeReqType.factory()
            obj_.build(child_)
            self.finance_type.append(obj_)
        elif nodeName_ == 'tied-status':
            obj_ = codeReqType.factory()
            obj_.build(child_)
            self.tied_status.append(obj_)
        elif nodeName_ == 'disbursement-channel':
            obj_ = codeReqType.factory()
            obj_.build(child_)
            self.disbursement_channel.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'transaction')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class transaction


class location(GeneratedsSuper):
    """A geographical location."""
    subclass = None
    superclass = None
    def __init__(self, percentage=None, location_type=None, name=None, description=None, administrative=None, coordinates=None, gazetteer_entry=None, anytypeobjs_=None):
        self.percentage = _cast(None, percentage)
        if location_type is None:
            self.location_type = []
        else:
            self.location_type = location_type
        if name is None:
            self.name = []
        else:
            self.name = name
        if description is None:
            self.description = []
        else:
            self.description = description
        if administrative is None:
            self.administrative = []
        else:
            self.administrative = administrative
        if coordinates is None:
            self.coordinates = []
        else:
            self.coordinates = coordinates
        if gazetteer_entry is None:
            self.gazetteer_entry = []
        else:
            self.gazetteer_entry = gazetteer_entry
        self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if location.subclass:
            return location.subclass(*args_, **kwargs_)
        else:
            return location(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_location_type(self): return self.location_type
    def set_location_type(self, location_type): self.location_type = location_type
    def add_location_type(self, value): self.location_type.append(value)
    def insert_location_type(self, index, value): self.location_type[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def add_name(self, value): self.name.append(value)
    def insert_name(self, index, value): self.name[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def add_description(self, value): self.description.append(value)
    def insert_description(self, index, value): self.description[index] = value
    def get_administrative(self): return self.administrative
    def set_administrative(self, administrative): self.administrative = administrative
    def add_administrative(self, value): self.administrative.append(value)
    def insert_administrative(self, index, value): self.administrative[index] = value
    def get_coordinates(self): return self.coordinates
    def set_coordinates(self, coordinates): self.coordinates = coordinates
    def add_coordinates(self, value): self.coordinates.append(value)
    def insert_coordinates(self, index, value): self.coordinates[index] = value
    def get_gazetteer_entry(self): return self.gazetteer_entry
    def set_gazetteer_entry(self, gazetteer_entry): self.gazetteer_entry = gazetteer_entry
    def add_gazetteer_entry(self, value): self.gazetteer_entry.append(value)
    def insert_gazetteer_entry(self, index, value): self.gazetteer_entry[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_percentage(self): return self.percentage
    def set_percentage(self, percentage): self.percentage = percentage
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.location_type or
            self.name or
            self.description or
            self.administrative or
            self.coordinates or
            self.gazetteer_entry or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='location', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='location')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='location', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='location'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.percentage is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            outfile.write(' percentage=%s' % (self.gds_format_string(quote_attrib(self.percentage).encode(ExternalEncoding), input_name='percentage'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='location', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for location_type_ in self.location_type:
            location_type_.export(outfile, level, namespace_, name_='location-type', pretty_print=pretty_print)
        for name_ in self.name:
            name_.export(outfile, level, namespace_, name_='name', pretty_print=pretty_print)
        for description_ in self.description:
            description_.export(outfile, level, namespace_, name_='description', pretty_print=pretty_print)
        for administrative_ in self.administrative:
            administrative_.export(outfile, level, namespace_, name_='administrative', pretty_print=pretty_print)
        for coordinates_ in self.coordinates:
            coordinates_.export(outfile, level, namespace_, name_='coordinates', pretty_print=pretty_print)
        for gazetteer_entry_ in self.gazetteer_entry:
            gazetteer_entry_.export(outfile, level, namespace_, name_='gazetteer-entry', pretty_print=pretty_print)
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='location'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.percentage is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            showIndent(outfile, level)
            outfile.write('percentage="%s",\n' % (self.percentage,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('location_type=[\n')
        level += 1
        for location_type_ in self.location_type:
            showIndent(outfile, level)
            outfile.write('model_.codeReqType(\n')
            location_type_.exportLiteral(outfile, level, name_='codeReqType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('name=[\n')
        level += 1
        for name_ in self.name:
            showIndent(outfile, level)
            outfile.write('model_.textType(\n')
            name_.exportLiteral(outfile, level, name_='textType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('description=[\n')
        level += 1
        for description_ in self.description:
            showIndent(outfile, level)
            outfile.write('model_.textType(\n')
            description_.exportLiteral(outfile, level, name_='textType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('administrative=[\n')
        level += 1
        for administrative_ in self.administrative:
            showIndent(outfile, level)
            outfile.write('model_.administrativeType(\n')
            administrative_.exportLiteral(outfile, level, name_='administrativeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('coordinates=[\n')
        level += 1
        for coordinates_ in self.coordinates:
            showIndent(outfile, level)
            outfile.write('model_.coordinatesType(\n')
            coordinates_.exportLiteral(outfile, level, name_='coordinatesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('gazetteer_entry=[\n')
        level += 1
        for gazetteer_entry_ in self.gazetteer_entry:
            showIndent(outfile, level)
            outfile.write('model_.gazetteer_entryType(\n')
            gazetteer_entry_.exportLiteral(outfile, level, name_='gazetteer-entryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('percentage', node)
        if value is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            self.percentage = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'location-type':
            obj_ = codeReqType.factory()
            obj_.build(child_)
            self.location_type.append(obj_)
        elif nodeName_ == 'name':
            obj_ = textType.factory()
            obj_.build(child_)
            self.name.append(obj_)
        elif nodeName_ == 'description':
            obj_ = textType.factory()
            obj_.build(child_)
            self.description.append(obj_)
        elif nodeName_ == 'administrative':
            obj_ = administrativeType.factory()
            obj_.build(child_)
            self.administrative.append(obj_)
        elif nodeName_ == 'coordinates':
            obj_ = coordinatesType.factory()
            obj_.build(child_)
            self.coordinates.append(obj_)
        elif nodeName_ == 'gazetteer-entry':
            obj_ = gazetteer_entryType.factory()
            obj_.build(child_)
            self.gazetteer_entry.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'location')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class location


class country_budget_items(GeneratedsSuper):
    """Recipient country budget items. This item encodes the alignment of
    activities with both the functional and administrative
    classifications used in the recipient country's Chart of
    Accounts. This applies to both on- and off-budget activities. A
    code for the common functional classification or country system
    (This allows for common codes, country-specific, or any other
    classification agreed between countries and donors)."""
    subclass = None
    superclass = None
    def __init__(self, vocabulary=None, budget_item=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.vocabulary = _cast(None, vocabulary)
        if budget_item is None:
            self.budget_item = []
        else:
            self.budget_item = budget_item
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if country_budget_items.subclass:
            return country_budget_items.subclass(*args_, **kwargs_)
        else:
            return country_budget_items(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_budget_item(self): return self.budget_item
    def set_budget_item(self, budget_item): self.budget_item = budget_item
    def add_budget_item(self, value): self.budget_item.append(value)
    def insert_budget_item(self, index, value): self.budget_item[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_vocabulary(self): return self.vocabulary
    def set_vocabulary(self, vocabulary): self.vocabulary = vocabulary
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.budget_item or
            self.anytypeobjs_ or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='country-budget-items', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='country-budget-items')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='country-budget-items', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='country-budget-items'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.vocabulary is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            outfile.write(' vocabulary=%s' % (self.gds_format_string(quote_attrib(self.vocabulary).encode(ExternalEncoding), input_name='vocabulary'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='country-budget-items', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='country-budget-items'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vocabulary is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            showIndent(outfile, level)
            outfile.write('vocabulary="%s",\n' % (self.vocabulary,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vocabulary', node)
        if value is not None and 'vocabulary' not in already_processed:
            already_processed.add('vocabulary')
            self.vocabulary = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'budget-item':
            obj_ = budget_itemType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'budget-item', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_budget-item'):
              self.add_budget-item(obj_.value)
            elif hasattr(self, 'set_budget-item'):
              self.set_budget-item(obj_.value)
        elif nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class country_budget_items


class related_activity(GeneratedsSuper):
    """XX.XX Related Activity Another IATI activity related to this one.
    The 'type' attribute describes the type of relationship (e.g.
    parent, sibling). This does not need to be used to express
    funding relationships, since those are covered in individual
    transactions. For the value of the @type attribute, see
    http://iatistandard.org/codelists/related_activity_type"""
    subclass = None
    superclass = None
    def __init__(self, lang=None, type_=None, ref=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.lang = _cast(None, lang)
        self.type_ = _cast(None, type_)
        self.ref = _cast(None, ref)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if related_activity.subclass:
            return related_activity.subclass(*args_, **kwargs_)
        else:
            return related_activity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='related-activity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='related-activity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='related-activity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='related-activity'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='related-activity', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='related-activity'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            showIndent(outfile, level)
            outfile.write('ref="%s",\n' % (self.ref,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class related_activity


class legacy_data(GeneratedsSuper):
    """Hold a single name=value pair of legacy data. This element is *not*
    for adding new data types; instead, it holds the original (non-
    IATI) value or code for an existing data type. The original
    field name. The original field value. The name of the equivalent
    IATI element (if available)."""
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, iati_equivalent=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.name = _cast(None, name)
        self.value = _cast(None, value)
        self.iati_equivalent = _cast(None, iati_equivalent)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if legacy_data.subclass:
            return legacy_data.subclass(*args_, **kwargs_)
        else:
            return legacy_data(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_iati_equivalent(self): return self.iati_equivalent
    def set_iati_equivalent(self, iati_equivalent): self.iati_equivalent = iati_equivalent
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='legacy-data', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='legacy-data')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='legacy-data', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='legacy-data'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.iati_equivalent is not None and 'iati_equivalent' not in already_processed:
            already_processed.add('iati_equivalent')
            outfile.write(' iati-equivalent=%s' % (self.gds_format_string(quote_attrib(self.iati_equivalent).encode(ExternalEncoding), input_name='iati-equivalent'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='legacy-data', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='legacy-data'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.iati_equivalent is not None and 'iati_equivalent' not in already_processed:
            already_processed.add('iati_equivalent')
            showIndent(outfile, level)
            outfile.write('iati_equivalent="%s",\n' % (self.iati_equivalent,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('iati-equivalent', node)
        if value is not None and 'iati-equivalent' not in already_processed:
            already_processed.add('iati-equivalent')
            self.iati_equivalent = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class legacy_data


class result(GeneratedsSuper):
    """A measurable result of aid work. Boolean flag indicating whether the
    data in the result set are suitable for aggregation."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, aggregation_status=None, title=None, description=None, indicator=None, anytypeobjs_=None):
        self.type_ = _cast(None, type_)
        self.aggregation_status = _cast(bool, aggregation_status)
        if title is None:
            self.title = []
        else:
            self.title = title
        if description is None:
            self.description = []
        else:
            self.description = description
        if indicator is None:
            self.indicator = []
        else:
            self.indicator = indicator
        self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if result.subclass:
            return result.subclass(*args_, **kwargs_)
        else:
            return result(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def add_title(self, value): self.title.append(value)
    def insert_title(self, index, value): self.title[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def add_description(self, value): self.description.append(value)
    def insert_description(self, index, value): self.description[index] = value
    def get_indicator(self): return self.indicator
    def set_indicator(self, indicator): self.indicator = indicator
    def add_indicator(self, value): self.indicator.append(value)
    def insert_indicator(self, index, value): self.indicator[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_aggregation_status(self): return self.aggregation_status
    def set_aggregation_status(self, aggregation_status): self.aggregation_status = aggregation_status
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.title or
            self.description or
            self.indicator or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='result', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='result')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='result', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='result'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.aggregation_status is not None and 'aggregation_status' not in already_processed:
            already_processed.add('aggregation_status')
            outfile.write(' aggregation-status="%s"' % self.gds_format_boolean(self.aggregation_status, input_name='aggregation-status'))
    def exportChildren(self, outfile, level, namespace_='', name_='result', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for title_ in self.title:
            title_.export(outfile, level, namespace_, name_='title', pretty_print=pretty_print)
        for description_ in self.description:
            description_.export(outfile, level, namespace_, name_='description', pretty_print=pretty_print)
        for indicator_ in self.indicator:
            indicator_.export(outfile, level, namespace_, name_='indicator', pretty_print=pretty_print)
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='result'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.aggregation_status is not None and 'aggregation_status' not in already_processed:
            already_processed.add('aggregation_status')
            showIndent(outfile, level)
            outfile.write('aggregation_status=%s,\n' % (self.aggregation_status,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('title=[\n')
        level += 1
        for title_ in self.title:
            showIndent(outfile, level)
            outfile.write('model_.title(\n')
            title_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('description=[\n')
        level += 1
        for description_ in self.description:
            showIndent(outfile, level)
            outfile.write('model_.description(\n')
            description_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('indicator=[\n')
        level += 1
        for indicator_ in self.indicator:
            showIndent(outfile, level)
            outfile.write('model_.indicatorType(\n')
            indicator_.exportLiteral(outfile, level, name_='indicatorType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('aggregation-status', node)
        if value is not None and 'aggregation-status' not in already_processed:
            already_processed.add('aggregation-status')
            if value in ('true', '1'):
                self.aggregation_status = True
            elif value in ('false', '0'):
                self.aggregation_status = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            obj_ = textType.factory()
            obj_.build(child_)
            self.title.append(obj_)
        elif nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.description.append(obj_)
        elif nodeName_ == 'indicator':
            obj_ = indicatorType.factory()
            obj_.build(child_)
            self.indicator.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'result')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class result


class indicatorOutcomeType(GeneratedsSuper):
    """Content type for a baseline or actual/planned outcome for an
    indicator. The year of the baseline or outcome. The value of the
    baseline or outcome."""
    subclass = None
    superclass = None
    def __init__(self, lang=None, value=None, year=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.lang = _cast(None, lang)
        self.value = _cast(None, value)
        self.year = _cast(None, year)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if indicatorOutcomeType.subclass:
            return indicatorOutcomeType.subclass(*args_, **kwargs_)
        else:
            return indicatorOutcomeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_year(self): return self.year
    def set_year(self, year): self.year = year
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indicatorOutcomeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indicatorOutcomeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='indicatorOutcomeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indicatorOutcomeType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.year is not None and 'year' not in already_processed:
            already_processed.add('year')
            outfile.write(' year=%s' % (self.gds_format_string(quote_attrib(self.year).encode(ExternalEncoding), input_name='year'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='indicatorOutcomeType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='indicatorOutcomeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.year is not None and 'year' not in already_processed:
            already_processed.add('year')
            showIndent(outfile, level)
            outfile.write('year="%s",\n' % (self.year,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('year', node)
        if value is not None and 'year' not in already_processed:
            already_processed.add('year')
            self.year = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class indicatorOutcomeType


class conditions(GeneratedsSuper):
    """Conditions attached to the activity. A yes/no (1/0) value stating
    whether there are conditions attached to the activity."""
    subclass = None
    superclass = None
    def __init__(self, attached=None, condition=None, anytypeobjs_=None):
        self.attached = _cast(bool, attached)
        if condition is None:
            self.condition = []
        else:
            self.condition = condition
        self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if conditions.subclass:
            return conditions.subclass(*args_, **kwargs_)
        else:
            return conditions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_condition(self): return self.condition
    def set_condition(self, condition): self.condition = condition
    def add_condition(self, value): self.condition.append(value)
    def insert_condition(self, index, value): self.condition[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_attached(self): return self.attached
    def set_attached(self, attached): self.attached = attached
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.condition or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='conditions', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='conditions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='conditions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='conditions'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.attached is not None and 'attached' not in already_processed:
            already_processed.add('attached')
            outfile.write(' attached="%s"' % self.gds_format_boolean(self.attached, input_name='attached'))
    def exportChildren(self, outfile, level, namespace_='', name_='conditions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for condition_ in self.condition:
            condition_.export(outfile, level, namespace_, name_='condition', pretty_print=pretty_print)
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='conditions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.attached is not None and 'attached' not in already_processed:
            already_processed.add('attached')
            showIndent(outfile, level)
            outfile.write('attached=%s,\n' % (self.attached,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('condition=[\n')
        level += 1
        for condition_ in self.condition:
            showIndent(outfile, level)
            outfile.write('model_.conditionType(\n')
            condition_.exportLiteral(outfile, level, name_='conditionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('attached', node)
        if value is not None and 'attached' not in already_processed:
            already_processed.add('attached')
            if value in ('true', '1'):
                self.attached = True
            elif value in ('false', '0'):
                self.attached = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'condition':
            obj_ = conditionType.factory()
            obj_.build(child_)
            self.condition.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'conditions')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class conditions


class budget(GeneratedsSuper):
    """The value of the aid activity's budget for each financial year as in
    the original project document."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, period_start=None, period_end=None, value=None, anytypeobjs_=None):
        self.type_ = _cast(None, type_)
        if period_start is None:
            self.period_start = []
        else:
            self.period_start = period_start
        if period_end is None:
            self.period_end = []
        else:
            self.period_end = period_end
        if value is None:
            self.value = []
        else:
            self.value = value
        self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if budget.subclass:
            return budget.subclass(*args_, **kwargs_)
        else:
            return budget(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_period_start(self): return self.period_start
    def set_period_start(self, period_start): self.period_start = period_start
    def add_period_start(self, value): self.period_start.append(value)
    def insert_period_start(self, index, value): self.period_start[index] = value
    def get_period_end(self): return self.period_end
    def set_period_end(self, period_end): self.period_end = period_end
    def add_period_end(self, value): self.period_end.append(value)
    def insert_period_end(self, index, value): self.period_end[index] = value
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.period_start or
            self.period_end or
            self.value or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='budget', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='budget')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='budget', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='budget'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='budget', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for period_start_ in self.period_start:
            period_start_.export(outfile, level, namespace_, name_='period-start', pretty_print=pretty_print)
        for period_end_ in self.period_end:
            period_end_.export(outfile, level, namespace_, name_='period-end', pretty_print=pretty_print)
        for value_ in self.value:
            value_.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='budget'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('period_start=[\n')
        level += 1
        for period_start_ in self.period_start:
            showIndent(outfile, level)
            outfile.write('model_.dateType(\n')
            period_start_.exportLiteral(outfile, level, name_='dateType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('period_end=[\n')
        level += 1
        for period_end_ in self.period_end:
            showIndent(outfile, level)
            outfile.write('model_.dateType(\n')
            period_end_.exportLiteral(outfile, level, name_='dateType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('model_.currencyType(\n')
            value_.exportLiteral(outfile, level, name_='currencyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'period-start':
            obj_ = dateType.factory()
            obj_.build(child_)
            self.period_start.append(obj_)
        elif nodeName_ == 'period-end':
            obj_ = dateType.factory()
            obj_.build(child_)
            self.period_end.append(obj_)
        elif nodeName_ == 'value':
            obj_ = currencyType.factory()
            obj_.build(child_)
            self.value.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'budget')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class budget


class planned_disbursement(GeneratedsSuper):
    """The date on which this line of information was last updated.
    Previous updates for the same period should also be reported."""
    subclass = None
    superclass = None
    def __init__(self, updated=None, period_start=None, period_end=None, value=None, anytypeobjs_=None):
        if isinstance(updated, basestring):
            initvalue_ = datetime_.datetime.strptime(updated, '%Y-%m-%d').date()
        else:
            initvalue_ = updated
        self.updated = initvalue_
        if period_start is None:
            self.period_start = []
        else:
            self.period_start = period_start
        if period_end is None:
            self.period_end = []
        else:
            self.period_end = period_end
        if value is None:
            self.value = []
        else:
            self.value = value
        self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if planned_disbursement.subclass:
            return planned_disbursement.subclass(*args_, **kwargs_)
        else:
            return planned_disbursement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_period_start(self): return self.period_start
    def set_period_start(self, period_start): self.period_start = period_start
    def add_period_start(self, value): self.period_start.append(value)
    def insert_period_start(self, index, value): self.period_start[index] = value
    def get_period_end(self): return self.period_end
    def set_period_end(self, period_end): self.period_end = period_end
    def add_period_end(self, value): self.period_end.append(value)
    def insert_period_end(self, index, value): self.period_end[index] = value
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_updated(self): return self.updated
    def set_updated(self, updated): self.updated = updated
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.period_start or
            self.period_end or
            self.value or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='planned-disbursement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='planned-disbursement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='planned-disbursement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='planned-disbursement'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.updated is not None and 'updated' not in already_processed:
            already_processed.add('updated')
            outfile.write(' updated="%s"' % self.gds_format_date(self.updated, input_name='updated'))
    def exportChildren(self, outfile, level, namespace_='', name_='planned-disbursement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for period_start_ in self.period_start:
            period_start_.export(outfile, level, namespace_, name_='period-start', pretty_print=pretty_print)
        for period_end_ in self.period_end:
            period_end_.export(outfile, level, namespace_, name_='period-end', pretty_print=pretty_print)
        for value_ in self.value:
            value_.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='planned-disbursement'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.updated is not None and 'updated' not in already_processed:
            already_processed.add('updated')
            showIndent(outfile, level)
            outfile.write('updated=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.updated, input_name='updated'))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('period_start=[\n')
        level += 1
        for period_start_ in self.period_start:
            showIndent(outfile, level)
            outfile.write('model_.dateType(\n')
            period_start_.exportLiteral(outfile, level, name_='dateType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('period_end=[\n')
        level += 1
        for period_end_ in self.period_end:
            showIndent(outfile, level)
            outfile.write('model_.dateType(\n')
            period_end_.exportLiteral(outfile, level, name_='dateType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('model_.currencyType(\n')
            value_.exportLiteral(outfile, level, name_='currencyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('updated', node)
        if value is not None and 'updated' not in already_processed:
            already_processed.add('updated')
            try:
                self.updated = self.gds_parse_date(value)
            except ValueError, exp:
                raise ValueError('Bad date attribute (updated): %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'period-start':
            obj_ = dateType.factory()
            obj_.build(child_)
            self.period_start.append(obj_)
        elif nodeName_ == 'period-end':
            obj_ = dateType.factory()
            obj_.build(child_)
            self.period_end.append(obj_)
        elif nodeName_ == 'value':
            obj_ = currencyType.factory()
            obj_.build(child_)
            self.value.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'planned-disbursement')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class planned_disbursement


class crs_add(GeneratedsSuper):
    """Additional items specific to CRS++ reporting."""
    subclass = None
    superclass = None
    def __init__(self, aidtype_flag=None, loan_terms=None, loan_status=None, anytypeobjs_=None):
        if aidtype_flag is None:
            self.aidtype_flag = []
        else:
            self.aidtype_flag = aidtype_flag
        if loan_terms is None:
            self.loan_terms = []
        else:
            self.loan_terms = loan_terms
        if loan_status is None:
            self.loan_status = []
        else:
            self.loan_status = loan_status
        self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if crs_add.subclass:
            return crs_add.subclass(*args_, **kwargs_)
        else:
            return crs_add(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_aidtype_flag(self): return self.aidtype_flag
    def set_aidtype_flag(self, aidtype_flag): self.aidtype_flag = aidtype_flag
    def add_aidtype_flag(self, value): self.aidtype_flag.append(value)
    def insert_aidtype_flag(self, index, value): self.aidtype_flag[index] = value
    def get_loan_terms(self): return self.loan_terms
    def set_loan_terms(self, loan_terms): self.loan_terms = loan_terms
    def add_loan_terms(self, value): self.loan_terms.append(value)
    def insert_loan_terms(self, index, value): self.loan_terms[index] = value
    def get_loan_status(self): return self.loan_status
    def set_loan_status(self, loan_status): self.loan_status = loan_status
    def add_loan_status(self, value): self.loan_status.append(value)
    def insert_loan_status(self, index, value): self.loan_status[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.aidtype_flag or
            self.loan_terms or
            self.loan_status or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='crs-add', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='crs-add')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='crs-add', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='crs-add'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='crs-add', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for aidtype_flag_ in self.aidtype_flag:
            aidtype_flag_.export(outfile, level, namespace_, name_='aidtype-flag', pretty_print=pretty_print)
        for loan_terms_ in self.loan_terms:
            loan_terms_.export(outfile, level, namespace_, name_='loan-terms', pretty_print=pretty_print)
        for loan_status_ in self.loan_status:
            loan_status_.export(outfile, level, namespace_, name_='loan-status', pretty_print=pretty_print)
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='crs-add'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('aidtype_flag=[\n')
        level += 1
        for aidtype_flag_ in self.aidtype_flag:
            showIndent(outfile, level)
            outfile.write('model_.aidtype_flagType(\n')
            aidtype_flag_.exportLiteral(outfile, level, name_='aidtype-flagType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('loan_terms=[\n')
        level += 1
        for loan_terms_ in self.loan_terms:
            showIndent(outfile, level)
            outfile.write('model_.loan_termsType(\n')
            loan_terms_.exportLiteral(outfile, level, name_='loan-termsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('loan_status=[\n')
        level += 1
        for loan_status_ in self.loan_status:
            showIndent(outfile, level)
            outfile.write('model_.loan_statusType(\n')
            loan_status_.exportLiteral(outfile, level, name_='loan-statusType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'aidtype-flag':
            obj_ = aidtype_flagType.factory()
            obj_.build(child_)
            self.aidtype_flag.append(obj_)
        elif nodeName_ == 'loan-terms':
            obj_ = loan_termsType.factory()
            obj_.build(child_)
            self.loan_terms.append(obj_)
        elif nodeName_ == 'loan-status':
            obj_ = loan_statusType.factory()
            obj_.build(child_)
            self.loan_status.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'crs-add')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class crs_add


class fss(GeneratedsSuper):
    """This section allows entry of data required for the OECD DAC Forward
    Spending Survey at an activity level. The exact date when the
    information was collected or extracted from donors' aid
    management systems. True if the partner country is a priority
    partner country. If there are plans to phase out operations from
    the partner country, this column shows the projected year of
    last disbursements."""
    subclass = None
    superclass = None
    def __init__(self, priority=None, phaseout_year=None, extraction_date=None, forecast=None, anytypeobjs_=None):
        self.priority = _cast(bool, priority)
        self.phaseout_year = _cast(float, phaseout_year)
        if isinstance(extraction_date, basestring):
            initvalue_ = datetime_.datetime.strptime(extraction_date, '%Y-%m-%d').date()
        else:
            initvalue_ = extraction_date
        self.extraction_date = initvalue_
        if forecast is None:
            self.forecast = []
        else:
            self.forecast = forecast
        self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if fss.subclass:
            return fss.subclass(*args_, **kwargs_)
        else:
            return fss(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_forecast(self): return self.forecast
    def set_forecast(self, forecast): self.forecast = forecast
    def add_forecast(self, value): self.forecast.append(value)
    def insert_forecast(self, index, value): self.forecast[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_priority(self): return self.priority
    def set_priority(self, priority): self.priority = priority
    def get_phaseout_year(self): return self.phaseout_year
    def set_phaseout_year(self, phaseout_year): self.phaseout_year = phaseout_year
    def get_extraction_date(self): return self.extraction_date
    def set_extraction_date(self, extraction_date): self.extraction_date = extraction_date
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.forecast or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='fss', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fss')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='fss', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='fss'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.priority is not None and 'priority' not in already_processed:
            already_processed.add('priority')
            outfile.write(' priority="%s"' % self.gds_format_boolean(self.priority, input_name='priority'))
        if self.phaseout_year is not None and 'phaseout_year' not in already_processed:
            already_processed.add('phaseout_year')
            outfile.write(' phaseout-year="%s"' % self.gds_format_float(self.phaseout_year, input_name='phaseout-year'))
        if self.extraction_date is not None and 'extraction_date' not in already_processed:
            already_processed.add('extraction_date')
            outfile.write(' extraction-date="%s"' % self.gds_format_date(self.extraction_date, input_name='extraction-date'))
    def exportChildren(self, outfile, level, namespace_='', name_='fss', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for forecast_ in self.forecast:
            forecast_.export(outfile, level, namespace_, name_='forecast', pretty_print=pretty_print)
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='fss'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.priority is not None and 'priority' not in already_processed:
            already_processed.add('priority')
            showIndent(outfile, level)
            outfile.write('priority=%s,\n' % (self.priority,))
        if self.phaseout_year is not None and 'phaseout_year' not in already_processed:
            already_processed.add('phaseout_year')
            showIndent(outfile, level)
            outfile.write('phaseout_year=%f,\n' % (self.phaseout_year,))
        if self.extraction_date is not None and 'extraction_date' not in already_processed:
            already_processed.add('extraction_date')
            showIndent(outfile, level)
            outfile.write('extraction-date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.extraction_date, input_name='extraction-date'))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('forecast=[\n')
        level += 1
        for forecast_ in self.forecast:
            showIndent(outfile, level)
            outfile.write('model_.forecastType(\n')
            forecast_.exportLiteral(outfile, level, name_='forecastType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('priority', node)
        if value is not None and 'priority' not in already_processed:
            already_processed.add('priority')
            if value in ('true', '1'):
                self.priority = True
            elif value in ('false', '0'):
                self.priority = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('phaseout-year', node)
        if value is not None and 'phaseout-year' not in already_processed:
            already_processed.add('phaseout-year')
            try:
                self.phaseout_year = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (phaseout-year): %s' % exp)
        value = find_attr_value_('extraction-date', node)
        if value is not None and 'extraction-date' not in already_processed:
            already_processed.add('extraction-date')
            try:
                self.extraction_date = self.gds_parse_date(value)
            except ValueError, exp:
                raise ValueError('Bad date attribute (extraction-date): %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'forecast':
            obj_ = forecastType.factory()
            obj_.build(child_)
            self.forecast.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'fss')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class fss


class description(GeneratedsSuper):
    """A longer, human-readable description. May be repeated for different
    languages."""
    subclass = None
    superclass = None
    def __init__(self, lang=None, type_=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.lang = _cast(None, lang)
        self.type_ = _cast(None, type_)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if description.subclass:
            return description.subclass(*args_, **kwargs_)
        else:
            return description(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='description', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='description')
        if self.hasContent_():
            outfile.write('>')
            self.exportLiteral(outfile,level)
            #self.exportChildren(outfile, level + 1, namespace_='', name_='description', pretty_print=pretty_print)
            #showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='description'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='description', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='description'):
        #level += 1
        #already_processed = set()
        #self.exportLiteralAttributes(outfile, level, already_processed, name_)
        #if self.hasContent_():
        #    self.exportLiteralChildren(outfile, level, name_)
        #showIndent(outfile, level)
        outfile.write('%s' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class description


class iati_identifier(GeneratedsSuper):
    """A globally unique identifier for this activity. This should be in
    the form of the IATI Organisation Identifier (for the reporting
    organisation) concatenated to that organisation's activity
    identifier. (NB. Two or more reporting organisations may publish
    information on the same activity. To cross-reference these
    reports the other-identifier element should be used.)"""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if iati_identifier.subclass:
            return iati_identifier.subclass(*args_, **kwargs_)
        else:
            return iati_identifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='iati-identifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='iati-identifier')
        outfile.write('>')
        self.exportLiteral(outfile, level + 1, name_)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='iati-identifier'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='iati-identifier', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='iati-identifier'):
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        outfile.write('%s' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class iati_identifier


class reporting_org(GeneratedsSuper):
    """The organisation issuing the report. May be a primary source
    (reporting on its own activity as donor, implementing agency,
    etc) or a secondary source (reporting on the activities of
    another organisation). Specifying the @ref and @role attributes
    is strongly recommended. May contain the organisation name as
    content. For the value of the @type attribute, see
    http://iatistandard.org/codelists/organisation-type. For
    guidance on constructing the value of the @ref attribute, see
    http://iatistandard.org/org-ref"""
    subclass = None
    superclass = None
    def __init__(self, lang=None, type_=None, ref=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.lang = _cast(None, lang)
        self.type_ = _cast(None, type_)
        self.ref = _cast(None, ref)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if reporting_org.subclass:
            return reporting_org.subclass(*args_, **kwargs_)
        else:
            return reporting_org(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='reporting-org', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='reporting-org')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='reporting-org', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='reporting-org'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='reporting-org', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='reporting-org'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            showIndent(outfile, level)
            outfile.write('ref="%s",\n' % (self.ref,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class reporting_org


class document_link(GeneratedsSuper):
    """A categorized link to an external document. The target URL of the
    external document, e.g. "http://www.example.org/doc.html". The
    MIME type of the external document, e.g. "application/pdf". A
    partial list of MIME types appears at
    http://iatistandard.org/codelists/file_format"""
    subclass = None
    superclass = None
    def __init__(self, url=None, format=None, title=None, category=None, language=None, anytypeobjs_=None):
        self.url = _cast(None, url)
        self.format = _cast(None, format)
        if title is None:
            self.title = []
        else:
            self.title = title
        if category is None:
            self.category = []
        else:
            self.category = category
        if language is None:
            self.language = []
        else:
            self.language = language
        self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if document_link.subclass:
            return document_link.subclass(*args_, **kwargs_)
        else:
            return document_link(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def add_title(self, value): self.title.append(value)
    def insert_title(self, index, value): self.title[index] = value
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def add_category(self, value): self.category.append(value)
    def insert_category(self, index, value): self.category[index] = value
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def add_language(self, value): self.language.append(value)
    def insert_language(self, index, value): self.language[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.title or
            self.category or
            self.language or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='document-link', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='document-link')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='document-link', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='document-link'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.url is not None and 'url' not in already_processed:
            already_processed.add('url')
            outfile.write(' url=%s' % (self.gds_format_string(quote_attrib(self.url).encode(ExternalEncoding), input_name='url'), ))
        if self.format is not None and 'format' not in already_processed:
            already_processed.add('format')
            outfile.write(' format=%s' % (self.gds_format_string(quote_attrib(self.format).encode(ExternalEncoding), input_name='format'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='document-link', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for title_ in self.title:
            title_.export(outfile, level, namespace_, name_='title', pretty_print=pretty_print)
        for category_ in self.category:
            category_.export(outfile, level, namespace_, name_='category', pretty_print=pretty_print)
        for language_ in self.language:
            language_.export(outfile, level, namespace_, name_='language', pretty_print=pretty_print)
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='document-link'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.url is not None and 'url' not in already_processed:
            already_processed.add('url')
            showIndent(outfile, level)
            outfile.write('url="%s",\n' % (self.url,))
        if self.format is not None and 'format' not in already_processed:
            already_processed.add('format')
            showIndent(outfile, level)
            outfile.write('format="%s",\n' % (self.format,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('title=[\n')
        level += 1
        for title_ in self.title:
            showIndent(outfile, level)
            outfile.write('model_.title(\n')
            title_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('category=[\n')
        level += 1
        for category_ in self.category:
            showIndent(outfile, level)
            outfile.write('model_.codeReqType(\n')
            category_.exportLiteral(outfile, level, name_='codeReqType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('language=[\n')
        level += 1
        for language_ in self.language:
            showIndent(outfile, level)
            outfile.write('model_.codeType(\n')
            language_.exportLiteral(outfile, level, name_='codeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('url', node)
        if value is not None and 'url' not in already_processed:
            already_processed.add('url')
            self.url = value
        value = find_attr_value_('format', node)
        if value is not None and 'format' not in already_processed:
            already_processed.add('format')
            self.format = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            obj_ = textType.factory()
            obj_.build(child_)
            self.title.append(obj_)
        elif nodeName_ == 'category':
            obj_ = codeReqType.factory()
            obj_.build(child_)
            self.category.append(obj_)
        elif nodeName_ == 'language':
            obj_ = codeType.factory()
            obj_.build(child_)
            self.language.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'document-link')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class document_link


class plainType(GeneratedsSuper):
    """Plain text content with no special attributes (e.g. xml:lang),
    though extended attributes are still allowed."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if plainType.subclass:
            return plainType.subclass(*args_, **kwargs_)
        else:
            return plainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='plainType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='plainType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='plainType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='plainType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='plainType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class plainType


class textType(GeneratedsSuper):
    """Data type for an element that may contain human-readable text in
    different languages."""
    subclass = None
    superclass = None
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.lang = _cast(None, lang)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if textType.subclass:
            return textType.subclass(*args_, **kwargs_)
        else:
            return textType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='textType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='textType')
        if self.hasContent_():
            outfile.write('>')
            self.exportLiteral(outfile, level)
            #self.exportChildren(outfile, level + 1, namespace_='', name_='textType', pretty_print=pretty_print)
            #showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='textType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='textType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='textType'):
        #level += 1
        already_processed = set()
        #self.exportLiteralAttributes(outfile, level, already_processed, name_)
        #if self.hasContent_():
        #    self.exportLiteralChildren(outfile, level, name_)
        #showIndent(outfile, level)
        outfile.write('%s' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class textType


class codeType(GeneratedsSuper):
    """Data type for an element that refers to an object that can have a
    code as well as human-readable text in different languages (e.g.
    a country or status)."""
    subclass = None
    superclass = None
    def __init__(self, lang=None, code=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.lang = _cast(None, lang)
        self.code = _cast(None, code)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if codeType.subclass:
            return codeType.subclass(*args_, **kwargs_)
        else:
            return codeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='codeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='codeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='codeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='codeType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='codeType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='codeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class codeType


class codeReqType(GeneratedsSuper):
    """Data type for an element that refers to an object that must have a
    code."""
    subclass = None
    superclass = None
    def __init__(self, lang=None, code=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.lang = _cast(None, lang)
        self.code = _cast(None, code)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if codeReqType.subclass:
            return codeReqType.subclass(*args_, **kwargs_)
        else:
            return codeReqType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='codeReqType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='codeReqType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='codeReqType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='codeReqType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='codeReqType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='codeReqType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class codeReqType


class refType(GeneratedsSuper):
    """Data type for an element that refers to a business object that can
    have unique identifier as well as human-readable text in
    different languages (e.g. an organisation)."""
    subclass = None
    superclass = None
    def __init__(self, lang=None, ref=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.lang = _cast(None, lang)
        self.ref = _cast(None, ref)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if refType.subclass:
            return refType.subclass(*args_, **kwargs_)
        else:
            return refType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='refType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='refType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='refType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='refType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='refType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='refType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            showIndent(outfile, level)
            outfile.write('ref="%s",\n' % (self.ref,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class refType


class refReqType(GeneratedsSuper):
    """Data type for an element that refers to a business object that can
    have unique identifier as well as human-readable text in
    different languages (e.g. an organisation), where the identifier
    reference is required."""
    subclass = None
    superclass = None
    def __init__(self, lang=None, ref=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.lang = _cast(None, lang)
        self.ref = _cast(None, ref)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if refReqType.subclass:
            return refReqType.subclass(*args_, **kwargs_)
        else:
            return refReqType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='refReqType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='refReqType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='refReqType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='refReqType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='refReqType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='refReqType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            showIndent(outfile, level)
            outfile.write('ref="%s",\n' % (self.ref,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class refReqType


class currencyType(GeneratedsSuper):
    """Data type for an element containing a currency value."""
    subclass = None
    superclass = None
    def __init__(self, currency=None, value_date=None, valueOf_=None):
        self.currency = _cast(None, currency)
        self.value_date = _cast(None, value_date)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if currencyType.subclass:
            return currencyType.subclass(*args_, **kwargs_)
        else:
            return currencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_value_date(self): return self.value_date
    def set_value_date(self, value_date): self.value_date = value_date
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='currencyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='currencyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='currencyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='currencyType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            outfile.write(' currency=%s' % (self.gds_format_string(quote_attrib(self.currency).encode(ExternalEncoding), input_name='currency'), ))
        if self.value_date is not None and 'value_date' not in already_processed:
            already_processed.add('value_date')
            outfile.write(' value-date=%s' % (self.gds_format_string(quote_attrib(self.value_date).encode(ExternalEncoding), input_name='value-date'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='currencyType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='currencyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            showIndent(outfile, level)
            outfile.write('currency="%s",\n' % (self.currency,))
        if self.value_date is not None and 'value_date' not in already_processed:
            already_processed.add('value_date')
            showIndent(outfile, level)
            outfile.write('value_date="%s",\n' % (self.value_date,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('currency', node)
        if value is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            self.currency = value
        value = find_attr_value_('value-date', node)
        if value is not None and 'value-date' not in already_processed:
            already_processed.add('value-date')
            self.value_date = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class currencyType


class dateType(GeneratedsSuper):
    """A date. The ISO 8601 date goes into the @iso-date attribute. The
    content may be free-form text. The ISO 8601 date."""
    subclass = None
    superclass = None
    def __init__(self, iso_date=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        if isinstance(iso_date, basestring):
            initvalue_ = datetime_.datetime.strptime(iso_date, '%Y-%m-%d').date()
        else:
            initvalue_ = iso_date
        self.iso_date = initvalue_
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if dateType.subclass:
            return dateType.subclass(*args_, **kwargs_)
        else:
            return dateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_iso_date(self): return self.iso_date
    def set_iso_date(self, iso_date): self.iso_date = iso_date
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dateType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dateType'):
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            outfile.write(' iso-date="%s"' % self.gds_format_date(self.iso_date, input_name='iso-date'))
    def exportChildren(self, outfile, level, namespace_='', name_='dateType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='dateType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            showIndent(outfile, level)
            outfile.write('iso-date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.iso_date, input_name='iso-date'))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('iso-date', node)
        if value is not None and 'iso-date' not in already_processed:
            already_processed.add('iso-date')
            try:
                self.iso_date = self.gds_parse_date(value)
            except ValueError, exp:
                raise ValueError('Bad date attribute (iso-date): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class dateType


class dateReqType(GeneratedsSuper):
    """A date. The ISO 8601 date goes into the @iso-date attribute. The
    content may be free-form text. The ISO 8601 date."""
    subclass = None
    superclass = None
    def __init__(self, iso_date=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        if isinstance(iso_date, basestring):
            initvalue_ = datetime_.datetime.strptime(iso_date, '%Y-%m-%d').date()
        else:
            initvalue_ = iso_date
        self.iso_date = initvalue_
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if dateReqType.subclass:
            return dateReqType.subclass(*args_, **kwargs_)
        else:
            return dateReqType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_iso_date(self): return self.iso_date
    def set_iso_date(self, iso_date): self.iso_date = iso_date
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dateReqType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dateReqType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dateReqType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dateReqType'):
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            outfile.write(' iso-date="%s"' % self.gds_format_date(self.iso_date, input_name='iso-date'))
    def exportChildren(self, outfile, level, namespace_='', name_='dateReqType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='dateReqType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            showIndent(outfile, level)
            outfile.write('iso-date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.iso_date, input_name='iso-date'))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('iso-date', node)
        if value is not None and 'iso-date' not in already_processed:
            already_processed.add('iso-date')
            try:
                self.iso_date = self.gds_parse_date(value)
            except ValueError, exp:
                raise ValueError('Bad date attribute (iso-date): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class dateReqType


class telephoneType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if telephoneType.subclass:
            return telephoneType.subclass(*args_, **kwargs_)
        else:
            return telephoneType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='telephoneType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='telephoneType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='telephoneType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='telephoneType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='telephoneType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class telephoneType


class mailing_addressType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, lang=None, valueOf_=None, mixedclass_=None, content_=None):
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if mailing_addressType.subclass:
            return mailing_addressType.subclass(*args_, **kwargs_)
        else:
            return mailing_addressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='mailing-addressType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mailing-addressType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='mailing-addressType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='mailing-addressType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='mailing-addressType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class mailing_addressType


class provider_orgType(GeneratedsSuper):
    """If the funds are being provided from the budget of another activity
    that is reported to IATI, this should record the unique IATI
    activity identifier for that activity."""
    subclass = None
    superclass = None
    def __init__(self, provider_activity_id=None, ref=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.provider_activity_id = _cast(None, provider_activity_id)
        self.ref = _cast(None, ref)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if provider_orgType.subclass:
            return provider_orgType.subclass(*args_, **kwargs_)
        else:
            return provider_orgType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_provider_activity_id(self): return self.provider_activity_id
    def set_provider_activity_id(self, provider_activity_id): self.provider_activity_id = provider_activity_id
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='provider-orgType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='provider-orgType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='provider-orgType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='provider-orgType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.provider_activity_id is not None and 'provider_activity_id' not in already_processed:
            already_processed.add('provider_activity_id')
            outfile.write(' provider-activity-id=%s' % (self.gds_format_string(quote_attrib(self.provider_activity_id).encode(ExternalEncoding), input_name='provider-activity-id'), ))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='provider-orgType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='provider-orgType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.provider_activity_id is not None and 'provider_activity_id' not in already_processed:
            already_processed.add('provider_activity_id')
            showIndent(outfile, level)
            outfile.write('provider_activity_id="%s",\n' % (self.provider_activity_id,))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            showIndent(outfile, level)
            outfile.write('ref="%s",\n' % (self.ref,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('provider-activity-id', node)
        if value is not None and 'provider-activity-id' not in already_processed:
            already_processed.add('provider-activity-id')
            self.provider_activity_id = value
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class provider_orgType


class receiver_orgType(GeneratedsSuper):
    """If the funds are being provided to another activity that is reported
    to IATI, this should record the unique IATI activity identifier
    for that activity."""
    subclass = None
    superclass = None
    def __init__(self, receiver_activity_id=None, ref=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.receiver_activity_id = _cast(None, receiver_activity_id)
        self.ref = _cast(None, ref)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if receiver_orgType.subclass:
            return receiver_orgType.subclass(*args_, **kwargs_)
        else:
            return receiver_orgType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_receiver_activity_id(self): return self.receiver_activity_id
    def set_receiver_activity_id(self, receiver_activity_id): self.receiver_activity_id = receiver_activity_id
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='receiver-orgType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='receiver-orgType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='receiver-orgType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='receiver-orgType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.receiver_activity_id is not None and 'receiver_activity_id' not in already_processed:
            already_processed.add('receiver_activity_id')
            outfile.write(' receiver-activity-id=%s' % (self.gds_format_string(quote_attrib(self.receiver_activity_id).encode(ExternalEncoding), input_name='receiver-activity-id'), ))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='receiver-orgType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='receiver-orgType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.receiver_activity_id is not None and 'receiver_activity_id' not in already_processed:
            already_processed.add('receiver_activity_id')
            showIndent(outfile, level)
            outfile.write('receiver_activity_id="%s",\n' % (self.receiver_activity_id,))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            showIndent(outfile, level)
            outfile.write('ref="%s",\n' % (self.ref,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('receiver-activity-id', node)
        if value is not None and 'receiver-activity-id' not in already_processed:
            already_processed.add('receiver-activity-id')
            self.receiver_activity_id = value
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class receiver_orgType


class transaction_dateType(GeneratedsSuper):
    """The ISO 8601 version of the transaction date."""
    subclass = None
    superclass = None
    def __init__(self, iso_date=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        if isinstance(iso_date, basestring):
            initvalue_ = datetime_.datetime.strptime(iso_date, '%Y-%m-%d').date()
        else:
            initvalue_ = iso_date
        self.iso_date = initvalue_
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if transaction_dateType.subclass:
            return transaction_dateType.subclass(*args_, **kwargs_)
        else:
            return transaction_dateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_iso_date(self): return self.iso_date
    def set_iso_date(self, iso_date): self.iso_date = iso_date
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='transaction-dateType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='transaction-dateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='transaction-dateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='transaction-dateType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            outfile.write(' iso-date="%s"' % self.gds_format_date(self.iso_date, input_name='iso-date'))
    def exportChildren(self, outfile, level, namespace_='', name_='transaction-dateType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='transaction-dateType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.iso_date is not None and 'iso_date' not in already_processed:
            already_processed.add('iso_date')
            showIndent(outfile, level)
            outfile.write('iso-date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.iso_date, input_name='iso-date'))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('iso-date', node)
        if value is not None and 'iso-date' not in already_processed:
            already_processed.add('iso-date')
            try:
                self.iso_date = self.gds_parse_date(value)
            except ValueError, exp:
                raise ValueError('Bad date attribute (iso-date): %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class transaction_dateType


class administrativeType(GeneratedsSuper):
    """The ISO 3166-1 alpha2 code for the country (e.g. "GB" for the United
    Kingdom). For the @code attribute, see
    http://iatistandard.org/codelists/country The UNSALB level-one
    administrative code for a subdivision of a country. See
    http://iatistandard.org/codelists/admin1 The UNSALB level-two
    administrative code for a subdivision of a country. See
    http://iatistandard.org/codelists/admin2"""
    subclass = None
    superclass = None
    def __init__(self, country=None, adm1=None, adm2=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.country = _cast(None, country)
        self.adm1 = _cast(None, adm1)
        self.adm2 = _cast(None, adm2)
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if administrativeType.subclass:
            return administrativeType.subclass(*args_, **kwargs_)
        else:
            return administrativeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_adm1(self): return self.adm1
    def set_adm1(self, adm1): self.adm1 = adm1
    def get_adm2(self): return self.adm2
    def set_adm2(self, adm2): self.adm2 = adm2
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='administrativeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='administrativeType')
        if self.hasContent_():
            outfile.write('>')
            self.exportLiteral(outfile, level)
            #showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='administrativeType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.country is not None and 'country' not in already_processed:
            already_processed.add('country')
            outfile.write(' country=%s' % (self.gds_format_string(quote_attrib(self.country).encode(ExternalEncoding), input_name='country'), ))
        if self.adm1 is not None and 'adm1' not in already_processed:
            already_processed.add('adm1')
            outfile.write(' adm1=%s' % (self.gds_format_string(quote_attrib(self.adm1).encode(ExternalEncoding), input_name='adm1'), ))
        if self.adm2 is not None and 'adm2' not in already_processed:
            already_processed.add('adm2')
            outfile.write(' adm2=%s' % (self.gds_format_string(quote_attrib(self.adm2).encode(ExternalEncoding), input_name='adm2'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='administrativeType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='administrativeType'):
        #level += 1
        #already_processed = set()
        #self.exportLiteralAttributes(outfile, level, already_processed, name_)
        #if self.hasContent_():
        #    self.exportLiteralChildren(outfile, level, name_)
        #showIndent(outfile, level)
        outfile.write('%s' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.country is not None and 'country' not in already_processed:
            already_processed.add('country')
            showIndent(outfile, level)
            outfile.write('country="%s",\n' % (self.country,))
        if self.adm1 is not None and 'adm1' not in already_processed:
            already_processed.add('adm1')
            showIndent(outfile, level)
            outfile.write('adm1="%s",\n' % (self.adm1,))
        if self.adm2 is not None and 'adm2' not in already_processed:
            already_processed.add('adm2')
            showIndent(outfile, level)
            outfile.write('adm2="%s",\n' % (self.adm2,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('country', node)
        if value is not None and 'country' not in already_processed:
            already_processed.add('country')
            self.country = value
        value = find_attr_value_('adm1', node)
        if value is not None and 'adm1' not in already_processed:
            already_processed.add('adm1')
            self.adm1 = value
        value = find_attr_value_('adm2', node)
        if value is not None and 'adm2' not in already_processed:
            already_processed.add('adm2')
            self.adm2 = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class administrativeType


class coordinatesType(GeneratedsSuper):
    """The decimal latitude (north is positive), e.g. "45.5" for 45.5
    degrees north (45 degrees 30 minutes). The decimal longitude
    (east is positive), e.g. "-75.5" for 75.5 degrees west (74
    degrees 30 minutes). An IATI-defined subset of UCPD precision
    codes for the location (e.g. "2" for within 25 km of the
    specified latitude/longitude). See
    http://iatistandard.org/codelists/geographical_precision"""
    subclass = None
    superclass = None
    def __init__(self, latitude=None, precision=None, longitude=None, anytypeobjs_=None):
        self.latitude = _cast(float, latitude)
        self.precision = _cast(None, precision)
        self.longitude = _cast(float, longitude)
        self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if coordinatesType.subclass:
            return coordinatesType.subclass(*args_, **kwargs_)
        else:
            return coordinatesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_latitude(self): return self.latitude
    def set_latitude(self, latitude): self.latitude = latitude
    def get_precision(self): return self.precision
    def set_precision(self, precision): self.precision = precision
    def get_longitude(self): return self.longitude
    def set_longitude(self, longitude): self.longitude = longitude
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='coordinatesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='coordinatesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='coordinatesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='coordinatesType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.latitude is not None and 'latitude' not in already_processed:
            already_processed.add('latitude')
            outfile.write(' latitude="%s"' % self.gds_format_float(self.latitude, input_name='latitude'))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            outfile.write(' precision=%s' % (self.gds_format_string(quote_attrib(self.precision).encode(ExternalEncoding), input_name='precision'), ))
        if self.longitude is not None and 'longitude' not in already_processed:
            already_processed.add('longitude')
            outfile.write(' longitude="%s"' % self.gds_format_float(self.longitude, input_name='longitude'))
    def exportChildren(self, outfile, level, namespace_='', name_='coordinatesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='coordinatesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.latitude is not None and 'latitude' not in already_processed:
            already_processed.add('latitude')
            showIndent(outfile, level)
            outfile.write('latitude=%f,\n' % (self.latitude,))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            showIndent(outfile, level)
            outfile.write('precision="%s",\n' % (self.precision,))
        if self.longitude is not None and 'longitude' not in already_processed:
            already_processed.add('longitude')
            showIndent(outfile, level)
            outfile.write('longitude=%f,\n' % (self.longitude,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('latitude', node)
        if value is not None and 'latitude' not in already_processed:
            already_processed.add('latitude')
            try:
                self.latitude = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (latitude): %s' % exp)
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            self.precision = value
        value = find_attr_value_('longitude', node)
        if value is not None and 'longitude' not in already_processed:
            already_processed.add('longitude')
            try:
                self.longitude = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (longitude): %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'coordinatesType')
        if obj_ is not None:
            self.set_anytypeobjs_(obj_)
# end class coordinatesType


class gazetteer_entryType(GeneratedsSuper):
    """Reference to the gazetteer containing the entry. See
    http://iatistandard.org/codelists/gazetteer_agency"""
    subclass = None
    superclass = None
    def __init__(self, gazetteer_ref=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.gazetteer_ref = _cast(None, gazetteer_ref)
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if gazetteer_entryType.subclass:
            return gazetteer_entryType.subclass(*args_, **kwargs_)
        else:
            return gazetteer_entryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_gazetteer_ref(self): return self.gazetteer_ref
    def set_gazetteer_ref(self, gazetteer_ref): self.gazetteer_ref = gazetteer_ref
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='gazetteer-entryType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='gazetteer-entryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='gazetteer-entryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='gazetteer-entryType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.gazetteer_ref is not None and 'gazetteer_ref' not in already_processed:
            already_processed.add('gazetteer_ref')
            outfile.write(' gazetteer-ref=%s' % (self.gds_format_string(quote_attrib(self.gazetteer_ref).encode(ExternalEncoding), input_name='gazetteer-ref'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='gazetteer-entryType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='gazetteer-entryType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.gazetteer_ref is not None and 'gazetteer_ref' not in already_processed:
            already_processed.add('gazetteer_ref')
            showIndent(outfile, level)
            outfile.write('gazetteer_ref="%s",\n' % (self.gazetteer_ref,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('gazetteer-ref', node)
        if value is not None and 'gazetteer-ref' not in already_processed:
            already_processed.add('gazetteer-ref')
            self.gazetteer_ref = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class gazetteer_entryType


class budget_itemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, percentage=None, code=None, description=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.percentage = _cast(None, percentage)
        self.code = _cast(None, code)
        if description is None:
            self.description = []
        else:
            self.description = description
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if budget_itemType.subclass:
            return budget_itemType.subclass(*args_, **kwargs_)
        else:
            return budget_itemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def add_description(self, value): self.description.append(value)
    def insert_description(self, index, value): self.description[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_percentage(self): return self.percentage
    def set_percentage(self, percentage): self.percentage = percentage
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.description or
            self.anytypeobjs_ or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='budget-itemType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='budget-itemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='budget-itemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='budget-itemType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.percentage is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            outfile.write(' percentage=%s' % (self.gds_format_string(quote_attrib(self.percentage).encode(ExternalEncoding), input_name='percentage'), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='budget-itemType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='budget-itemType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.percentage is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            showIndent(outfile, level)
            outfile.write('percentage="%s",\n' % (self.percentage,))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('percentage', node)
        if value is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            self.percentage = value
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'description', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_description'):
              self.add_description(obj_.value)
            elif hasattr(self, 'set_description'):
              self.set_description(obj_.value)
        elif nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class budget_itemType


class indicatorType(GeneratedsSuper):
    """The type of measurement for the indicator value e.g. unit,
    percentage, NDP. True if the indicator improves from small to
    large (e.g. clinics built); false if it improves from large to
    small (e.g. cases of a disease). Defaults to true if omitted."""
    subclass = None
    superclass = None
    def __init__(self, ascending=None, measure=None, title=None, description=None, baseline=None, period=None, anytypeobjs_=None):
        self.ascending = _cast(bool, ascending)
        self.measure = _cast(None, measure)
        if title is None:
            self.title = []
        else:
            self.title = title
        if description is None:
            self.description = []
        else:
            self.description = description
        if baseline is None:
            self.baseline = []
        else:
            self.baseline = baseline
        if period is None:
            self.period = []
        else:
            self.period = period
        self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if indicatorType.subclass:
            return indicatorType.subclass(*args_, **kwargs_)
        else:
            return indicatorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def add_title(self, value): self.title.append(value)
    def insert_title(self, index, value): self.title[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def add_description(self, value): self.description.append(value)
    def insert_description(self, index, value): self.description[index] = value
    def get_baseline(self): return self.baseline
    def set_baseline(self, baseline): self.baseline = baseline
    def add_baseline(self, value): self.baseline.append(value)
    def insert_baseline(self, index, value): self.baseline[index] = value
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def add_period(self, value): self.period.append(value)
    def insert_period(self, index, value): self.period[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_ascending(self): return self.ascending
    def set_ascending(self, ascending): self.ascending = ascending
    def get_measure(self): return self.measure
    def set_measure(self, measure): self.measure = measure
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.title or
            self.description or
            self.baseline or
            self.period or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indicatorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indicatorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='indicatorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indicatorType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.ascending is not None and 'ascending' not in already_processed:
            already_processed.add('ascending')
            outfile.write(' ascending="%s"' % self.gds_format_boolean(self.ascending, input_name='ascending'))
        if self.measure is not None and 'measure' not in already_processed:
            already_processed.add('measure')
            outfile.write(' measure=%s' % (self.gds_format_string(quote_attrib(self.measure).encode(ExternalEncoding), input_name='measure'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='indicatorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for title_ in self.title:
            title_.export(outfile, level, namespace_, name_='title', pretty_print=pretty_print)
        for description_ in self.description:
            description_.export(outfile, level, namespace_, name_='description', pretty_print=pretty_print)
        for baseline_ in self.baseline:
            baseline_.export(outfile, level, namespace_, name_='baseline', pretty_print=pretty_print)
        for period_ in self.period:
            period_.export(outfile, level, namespace_, name_='period', pretty_print=pretty_print)
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='indicatorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ascending is not None and 'ascending' not in already_processed:
            already_processed.add('ascending')
            showIndent(outfile, level)
            outfile.write('ascending=%s,\n' % (self.ascending,))
        if self.measure is not None and 'measure' not in already_processed:
            already_processed.add('measure')
            showIndent(outfile, level)
            outfile.write('measure="%s",\n' % (self.measure,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('title=[\n')
        level += 1
        for title_ in self.title:
            showIndent(outfile, level)
            outfile.write('model_.title(\n')
            title_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('description=[\n')
        level += 1
        for description_ in self.description:
            showIndent(outfile, level)
            outfile.write('model_.description(\n')
            description_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('baseline=[\n')
        level += 1
        for baseline_ in self.baseline:
            showIndent(outfile, level)
            outfile.write('model_.baselineType(\n')
            baseline_.exportLiteral(outfile, level, name_='baselineType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('period=[\n')
        level += 1
        for period_ in self.period:
            showIndent(outfile, level)
            outfile.write('model_.periodType(\n')
            period_.exportLiteral(outfile, level, name_='periodType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ascending', node)
        if value is not None and 'ascending' not in already_processed:
            already_processed.add('ascending')
            if value in ('true', '1'):
                self.ascending = True
            elif value in ('false', '0'):
                self.ascending = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('measure', node)
        if value is not None and 'measure' not in already_processed:
            already_processed.add('measure')
            self.measure = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            obj_ = textType.factory()
            obj_.build(child_)
            self.title.append(obj_)
        elif nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.description.append(obj_)
        elif nodeName_ == 'baseline':
            obj_ = baselineType.factory()
            obj_.build(child_)
            self.baseline.append(obj_)
        elif nodeName_ == 'period':
            obj_ = periodType.factory()
            obj_.build(child_)
            self.period.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'indicatorType')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class indicatorType


class baselineType(GeneratedsSuper):
    """The year the baseline value was taken The baseline value."""
    subclass = None
    superclass = None
    def __init__(self, value=None, year=None, comment=None, anytypeobjs_=None):
        self.value = _cast(None, value)
        self.year = _cast(int, year)
        if comment is None:
            self.comment = []
        else:
            self.comment = comment
        self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if baselineType.subclass:
            return baselineType.subclass(*args_, **kwargs_)
        else:
            return baselineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def add_comment(self, value): self.comment.append(value)
    def insert_comment(self, index, value): self.comment[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_year(self): return self.year
    def set_year(self, year): self.year = year
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.comment or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='baselineType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='baselineType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='baselineType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='baselineType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.year is not None and 'year' not in already_processed:
            already_processed.add('year')
            outfile.write(' year="%s"' % self.gds_format_integer(self.year, input_name='year'))
    def exportChildren(self, outfile, level, namespace_='', name_='baselineType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for comment_ in self.comment:
            comment_.export(outfile, level, namespace_, name_='comment', pretty_print=pretty_print)
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='baselineType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.year is not None and 'year' not in already_processed:
            already_processed.add('year')
            showIndent(outfile, level)
            outfile.write('year=%d,\n' % (self.year,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('comment=[\n')
        level += 1
        for comment_ in self.comment:
            showIndent(outfile, level)
            outfile.write('model_.comment(\n')
            comment_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('year', node)
        if value is not None and 'year' not in already_processed:
            already_processed.add('year')
            try:
                self.year = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.year <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'comment':
            obj_ = textType.factory()
            obj_.build(child_)
            self.comment.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'baselineType')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class baselineType


class periodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, period_start=None, period_end=None, target=None, actual=None, anytypeobjs_=None):
        if period_start is None:
            self.period_start = []
        else:
            self.period_start = period_start
        if period_end is None:
            self.period_end = []
        else:
            self.period_end = period_end
        if target is None:
            self.target = []
        else:
            self.target = target
        if actual is None:
            self.actual = []
        else:
            self.actual = actual
        self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if periodType.subclass:
            return periodType.subclass(*args_, **kwargs_)
        else:
            return periodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_period_start(self): return self.period_start
    def set_period_start(self, period_start): self.period_start = period_start
    def add_period_start(self, value): self.period_start.append(value)
    def insert_period_start(self, index, value): self.period_start[index] = value
    def get_period_end(self): return self.period_end
    def set_period_end(self, period_end): self.period_end = period_end
    def add_period_end(self, value): self.period_end.append(value)
    def insert_period_end(self, index, value): self.period_end[index] = value
    def get_target(self): return self.target
    def set_target(self, target): self.target = target
    def add_target(self, value): self.target.append(value)
    def insert_target(self, index, value): self.target[index] = value
    def get_actual(self): return self.actual
    def set_actual(self, actual): self.actual = actual
    def add_actual(self, value): self.actual.append(value)
    def insert_actual(self, index, value): self.actual[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.period_start or
            self.period_end or
            self.target or
            self.actual or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='periodType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='periodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='periodType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='periodType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='periodType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for period_start_ in self.period_start:
            period_start_.export(outfile, level, namespace_, name_='period-start', pretty_print=pretty_print)
        for period_end_ in self.period_end:
            period_end_.export(outfile, level, namespace_, name_='period-end', pretty_print=pretty_print)
        for target_ in self.target:
            target_.export(outfile, level, namespace_, name_='target', pretty_print=pretty_print)
        for actual_ in self.actual:
            actual_.export(outfile, level, namespace_, name_='actual', pretty_print=pretty_print)
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='periodType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('period_start=[\n')
        level += 1
        for period_start_ in self.period_start:
            showIndent(outfile, level)
            outfile.write('model_.dateType(\n')
            period_start_.exportLiteral(outfile, level, name_='dateType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('period_end=[\n')
        level += 1
        for period_end_ in self.period_end:
            showIndent(outfile, level)
            outfile.write('model_.dateType(\n')
            period_end_.exportLiteral(outfile, level, name_='dateType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('target=[\n')
        level += 1
        for target_ in self.target:
            showIndent(outfile, level)
            outfile.write('model_.targetType(\n')
            target_.exportLiteral(outfile, level, name_='targetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('actual=[\n')
        level += 1
        for actual_ in self.actual:
            showIndent(outfile, level)
            outfile.write('model_.actualType(\n')
            actual_.exportLiteral(outfile, level, name_='actualType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'period-start':
            obj_ = dateType.factory()
            obj_.build(child_)
            self.period_start.append(obj_)
        elif nodeName_ == 'period-end':
            obj_ = dateType.factory()
            obj_.build(child_)
            self.period_end.append(obj_)
        elif nodeName_ == 'target':
            obj_ = targetType.factory()
            obj_.build(child_)
            self.target.append(obj_)
        elif nodeName_ == 'actual':
            obj_ = actualType.factory()
            obj_.build(child_)
            self.actual.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'periodType')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class periodType


class targetType(GeneratedsSuper):
    """The target value."""
    subclass = None
    superclass = None
    def __init__(self, value=None, comment=None, anytypeobjs_=None):
        self.value = _cast(None, value)
        if comment is None:
            self.comment = []
        else:
            self.comment = comment
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if targetType.subclass:
            return targetType.subclass(*args_, **kwargs_)
        else:
            return targetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def add_comment(self, value): self.comment.append(value)
    def insert_comment(self, index, value): self.comment[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            self.comment or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='targetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='targetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='targetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='targetType'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='targetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for comment_ in self.comment:
            comment_.export(outfile, level, namespace_, name_='comment', pretty_print=pretty_print)
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='targetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('comment=[\n')
        level += 1
        for comment_ in self.comment:
            showIndent(outfile, level)
            outfile.write('model_.comment(\n')
            comment_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'comment':
            obj_ = textType.factory()
            obj_.build(child_)
            self.comment.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'targetType')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class targetType


class actualType(GeneratedsSuper):
    """The actual measure."""
    subclass = None
    superclass = None
    def __init__(self, value=None, comment=None, anytypeobjs_=None):
        self.value = _cast(None, value)
        if comment is None:
            self.comment = []
        else:
            self.comment = comment
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if actualType.subclass:
            return actualType.subclass(*args_, **kwargs_)
        else:
            return actualType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def add_comment(self, value): self.comment.append(value)
    def insert_comment(self, index, value): self.comment[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            self.comment or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='actualType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='actualType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='actualType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='actualType'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='actualType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for comment_ in self.comment:
            comment_.export(outfile, level, namespace_, name_='comment', pretty_print=pretty_print)
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='actualType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('comment=[\n')
        level += 1
        for comment_ in self.comment:
            showIndent(outfile, level)
            outfile.write('model_.comment(\n')
            comment_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'comment':
            obj_ = textType.factory()
            obj_.build(child_)
            self.comment.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'actualType')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class actualType


class conditionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.type_ = _cast(None, type_)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if conditionType.subclass:
            return conditionType.subclass(*args_, **kwargs_)
        else:
            return conditionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='conditionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='conditionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='conditionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='conditionType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='conditionType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='conditionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class conditionType


class aidtype_flagType(GeneratedsSuper):
    """Does this flag apply? If 'false' do not report the flag"""
    subclass = None
    superclass = None
    def __init__(self, code=None, significance=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.code = _cast(None, code)
        self.significance = _cast(bool, significance)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if aidtype_flagType.subclass:
            return aidtype_flagType.subclass(*args_, **kwargs_)
        else:
            return aidtype_flagType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_significance(self): return self.significance
    def set_significance(self, significance): self.significance = significance
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='aidtype-flagType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='aidtype-flagType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='aidtype-flagType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='aidtype-flagType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
        if self.significance is not None and 'significance' not in already_processed:
            already_processed.add('significance')
            outfile.write(' significance="%s"' % self.gds_format_boolean(self.significance, input_name='significance'))
    def exportChildren(self, outfile, level, namespace_='', name_='aidtype-flagType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='aidtype-flagType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code="%s",\n' % (self.code,))
        if self.significance is not None and 'significance' not in already_processed:
            already_processed.add('significance')
            showIndent(outfile, level)
            outfile.write('significance=%s,\n' % (self.significance,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        value = find_attr_value_('significance', node)
        if value is not None and 'significance' not in already_processed:
            already_processed.add('significance')
            if value in ('true', '1'):
                self.significance = True
            elif value in ('false', '0'):
                self.significance = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class aidtype_flagType


class loan_termsType(GeneratedsSuper):
    """Interest Rate. If an ODA loan with variable interest rate, report
    the variable rate here and the reference fixed rate as rate-2
    Enter the rate without the percentage sign. Second Interest
    Rate. If an ODA loan with variable interest rate, report the
    variable rate as rate-1 and the reference fixed rate here Enter
    the rate without the percentage sign."""
    subclass = None
    superclass = None
    def __init__(self, rate_2=None, rate_1=None, repayment_type=None, repayment_plan=None, commitment_date=None, repayment_first_date=None, repayment_final_date=None, anytypeobjs_=None):
        self.rate_2 = _cast(float, rate_2)
        self.rate_1 = _cast(float, rate_1)
        if repayment_type is None:
            self.repayment_type = []
        else:
            self.repayment_type = repayment_type
        if repayment_plan is None:
            self.repayment_plan = []
        else:
            self.repayment_plan = repayment_plan
        if commitment_date is None:
            self.commitment_date = []
        else:
            self.commitment_date = commitment_date
        if repayment_first_date is None:
            self.repayment_first_date = []
        else:
            self.repayment_first_date = repayment_first_date
        if repayment_final_date is None:
            self.repayment_final_date = []
        else:
            self.repayment_final_date = repayment_final_date
        self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if loan_termsType.subclass:
            return loan_termsType.subclass(*args_, **kwargs_)
        else:
            return loan_termsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_repayment_type(self): return self.repayment_type
    def set_repayment_type(self, repayment_type): self.repayment_type = repayment_type
    def add_repayment_type(self, value): self.repayment_type.append(value)
    def insert_repayment_type(self, index, value): self.repayment_type[index] = value
    def get_repayment_plan(self): return self.repayment_plan
    def set_repayment_plan(self, repayment_plan): self.repayment_plan = repayment_plan
    def add_repayment_plan(self, value): self.repayment_plan.append(value)
    def insert_repayment_plan(self, index, value): self.repayment_plan[index] = value
    def get_commitment_date(self): return self.commitment_date
    def set_commitment_date(self, commitment_date): self.commitment_date = commitment_date
    def add_commitment_date(self, value): self.commitment_date.append(value)
    def insert_commitment_date(self, index, value): self.commitment_date[index] = value
    def get_repayment_first_date(self): return self.repayment_first_date
    def set_repayment_first_date(self, repayment_first_date): self.repayment_first_date = repayment_first_date
    def add_repayment_first_date(self, value): self.repayment_first_date.append(value)
    def insert_repayment_first_date(self, index, value): self.repayment_first_date[index] = value
    def get_repayment_final_date(self): return self.repayment_final_date
    def set_repayment_final_date(self, repayment_final_date): self.repayment_final_date = repayment_final_date
    def add_repayment_final_date(self, value): self.repayment_final_date.append(value)
    def insert_repayment_final_date(self, index, value): self.repayment_final_date[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_rate_2(self): return self.rate_2
    def set_rate_2(self, rate_2): self.rate_2 = rate_2
    def get_rate_1(self): return self.rate_1
    def set_rate_1(self, rate_1): self.rate_1 = rate_1
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.repayment_type or
            self.repayment_plan or
            self.commitment_date or
            self.repayment_first_date or
            self.repayment_final_date or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='loan-termsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='loan-termsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='loan-termsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='loan-termsType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.rate_2 is not None and 'rate_2' not in already_processed:
            already_processed.add('rate_2')
            outfile.write(' rate-2="%s"' % self.gds_format_float(self.rate_2, input_name='rate-2'))
        if self.rate_1 is not None and 'rate_1' not in already_processed:
            already_processed.add('rate_1')
            outfile.write(' rate-1="%s"' % self.gds_format_float(self.rate_1, input_name='rate-1'))
    def exportChildren(self, outfile, level, namespace_='', name_='loan-termsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for repayment_type_ in self.repayment_type:
            repayment_type_.export(outfile, level, namespace_, name_='repayment-type', pretty_print=pretty_print)
        for repayment_plan_ in self.repayment_plan:
            repayment_plan_.export(outfile, level, namespace_, name_='repayment-plan', pretty_print=pretty_print)
        for commitment_date_ in self.commitment_date:
            commitment_date_.export(outfile, level, namespace_, name_='commitment-date', pretty_print=pretty_print)
        for repayment_first_date_ in self.repayment_first_date:
            repayment_first_date_.export(outfile, level, namespace_, name_='repayment-first-date', pretty_print=pretty_print)
        for repayment_final_date_ in self.repayment_final_date:
            repayment_final_date_.export(outfile, level, namespace_, name_='repayment-final-date', pretty_print=pretty_print)
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='loan-termsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rate_2 is not None and 'rate_2' not in already_processed:
            already_processed.add('rate_2')
            showIndent(outfile, level)
            outfile.write('rate_2=%f,\n' % (self.rate_2,))
        if self.rate_1 is not None and 'rate_1' not in already_processed:
            already_processed.add('rate_1')
            showIndent(outfile, level)
            outfile.write('rate_1=%f,\n' % (self.rate_1,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('repayment_type=[\n')
        level += 1
        for repayment_type_ in self.repayment_type:
            showIndent(outfile, level)
            outfile.write('model_.codeType(\n')
            repayment_type_.exportLiteral(outfile, level, name_='codeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('repayment_plan=[\n')
        level += 1
        for repayment_plan_ in self.repayment_plan:
            showIndent(outfile, level)
            outfile.write('model_.codeType(\n')
            repayment_plan_.exportLiteral(outfile, level, name_='codeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('commitment_date=[\n')
        level += 1
        for commitment_date_ in self.commitment_date:
            showIndent(outfile, level)
            outfile.write('model_.dateType(\n')
            commitment_date_.exportLiteral(outfile, level, name_='dateType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('repayment_first_date=[\n')
        level += 1
        for repayment_first_date_ in self.repayment_first_date:
            showIndent(outfile, level)
            outfile.write('model_.dateType(\n')
            repayment_first_date_.exportLiteral(outfile, level, name_='dateType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('repayment_final_date=[\n')
        level += 1
        for repayment_final_date_ in self.repayment_final_date:
            showIndent(outfile, level)
            outfile.write('model_.dateType(\n')
            repayment_final_date_.exportLiteral(outfile, level, name_='dateType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rate-2', node)
        if value is not None and 'rate-2' not in already_processed:
            already_processed.add('rate-2')
            try:
                self.rate_2 = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (rate-2): %s' % exp)
        value = find_attr_value_('rate-1', node)
        if value is not None and 'rate-1' not in already_processed:
            already_processed.add('rate-1')
            try:
                self.rate_1 = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (rate-1): %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'repayment-type':
            obj_ = codeType.factory()
            obj_.build(child_)
            self.repayment_type.append(obj_)
        elif nodeName_ == 'repayment-plan':
            obj_ = codeType.factory()
            obj_.build(child_)
            self.repayment_plan.append(obj_)
        elif nodeName_ == 'commitment-date':
            obj_ = dateType.factory()
            obj_.build(child_)
            self.commitment_date.append(obj_)
        elif nodeName_ == 'repayment-first-date':
            obj_ = dateType.factory()
            obj_.build(child_)
            self.repayment_first_date.append(obj_)
        elif nodeName_ == 'repayment-final-date':
            obj_ = dateType.factory()
            obj_.build(child_)
            self.repayment_final_date.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'loan-termsType')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class loan_termsType


class loan_statusType(GeneratedsSuper):
    """CRS Reporting Year (CRS++ Column 1)"""
    subclass = None
    superclass = None
    def __init__(self, currency=None, value_date=None, year=None, interest_received=None, principal_outstanding=None, principal_arrears=None, interest_arrears=None, anytypeobjs_=None):
        self.currency = _cast(None, currency)
        self.value_date = _cast(None, value_date)
        self.year = _cast(float, year)
        if interest_received is None:
            self.interest_received = []
        else:
            self.interest_received = interest_received
        if principal_outstanding is None:
            self.principal_outstanding = []
        else:
            self.principal_outstanding = principal_outstanding
        if principal_arrears is None:
            self.principal_arrears = []
        else:
            self.principal_arrears = principal_arrears
        if interest_arrears is None:
            self.interest_arrears = []
        else:
            self.interest_arrears = interest_arrears
        self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if loan_statusType.subclass:
            return loan_statusType.subclass(*args_, **kwargs_)
        else:
            return loan_statusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_interest_received(self): return self.interest_received
    def set_interest_received(self, interest_received): self.interest_received = interest_received
    def add_interest_received(self, value): self.interest_received.append(value)
    def insert_interest_received(self, index, value): self.interest_received[index] = value
    def get_principal_outstanding(self): return self.principal_outstanding
    def set_principal_outstanding(self, principal_outstanding): self.principal_outstanding = principal_outstanding
    def add_principal_outstanding(self, value): self.principal_outstanding.append(value)
    def insert_principal_outstanding(self, index, value): self.principal_outstanding[index] = value
    def get_principal_arrears(self): return self.principal_arrears
    def set_principal_arrears(self, principal_arrears): self.principal_arrears = principal_arrears
    def add_principal_arrears(self, value): self.principal_arrears.append(value)
    def insert_principal_arrears(self, index, value): self.principal_arrears[index] = value
    def get_interest_arrears(self): return self.interest_arrears
    def set_interest_arrears(self, interest_arrears): self.interest_arrears = interest_arrears
    def add_interest_arrears(self, value): self.interest_arrears.append(value)
    def insert_interest_arrears(self, index, value): self.interest_arrears[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_value_date(self): return self.value_date
    def set_value_date(self, value_date): self.value_date = value_date
    def get_year(self): return self.year
    def set_year(self, year): self.year = year
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.interest_received or
            self.principal_outstanding or
            self.principal_arrears or
            self.interest_arrears or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='loan-statusType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='loan-statusType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='loan-statusType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='loan-statusType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            outfile.write(' currency=%s' % (self.gds_format_string(quote_attrib(self.currency).encode(ExternalEncoding), input_name='currency'), ))
        if self.value_date is not None and 'value_date' not in already_processed:
            already_processed.add('value_date')
            outfile.write(' value-date=%s' % (self.gds_format_string(quote_attrib(self.value_date).encode(ExternalEncoding), input_name='value-date'), ))
        if self.year is not None and 'year' not in already_processed:
            already_processed.add('year')
            outfile.write(' year="%s"' % self.gds_format_float(self.year, input_name='year'))
    def exportChildren(self, outfile, level, namespace_='', name_='loan-statusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for interest_received_ in self.interest_received:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinterest-received>%s</%sinterest-received>%s' % (namespace_, self.gds_format_float(interest_received_, input_name='interest-received'), namespace_, eol_))
        for principal_outstanding_ in self.principal_outstanding:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprincipal-outstanding>%s</%sprincipal-outstanding>%s' % (namespace_, self.gds_format_float(principal_outstanding_, input_name='principal-outstanding'), namespace_, eol_))
        for principal_arrears_ in self.principal_arrears:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprincipal-arrears>%s</%sprincipal-arrears>%s' % (namespace_, self.gds_format_float(principal_arrears_, input_name='principal-arrears'), namespace_, eol_))
        for interest_arrears_ in self.interest_arrears:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinterest-arrears>%s</%sinterest-arrears>%s' % (namespace_, self.gds_format_float(interest_arrears_, input_name='interest-arrears'), namespace_, eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='loan-statusType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            showIndent(outfile, level)
            outfile.write('currency="%s",\n' % (self.currency,))
        if self.value_date is not None and 'value_date' not in already_processed:
            already_processed.add('value_date')
            showIndent(outfile, level)
            outfile.write('value_date="%s",\n' % (self.value_date,))
        if self.year is not None and 'year' not in already_processed:
            already_processed.add('year')
            showIndent(outfile, level)
            outfile.write('year=%f,\n' % (self.year,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('interest_received=[\n')
        level += 1
        for interest_received_ in self.interest_received:
            showIndent(outfile, level)
            outfile.write('%f,\n' % interest_received_)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('principal_outstanding=[\n')
        level += 1
        for principal_outstanding_ in self.principal_outstanding:
            showIndent(outfile, level)
            outfile.write('%f,\n' % principal_outstanding_)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('principal_arrears=[\n')
        level += 1
        for principal_arrears_ in self.principal_arrears:
            showIndent(outfile, level)
            outfile.write('%f,\n' % principal_arrears_)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('interest_arrears=[\n')
        level += 1
        for interest_arrears_ in self.interest_arrears:
            showIndent(outfile, level)
            outfile.write('%f,\n' % interest_arrears_)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('currency', node)
        if value is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            self.currency = value
        value = find_attr_value_('value-date', node)
        if value is not None and 'value-date' not in already_processed:
            already_processed.add('value-date')
            self.value_date = value
        value = find_attr_value_('year', node)
        if value is not None and 'year' not in already_processed:
            already_processed.add('year')
            try:
                self.year = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (year): %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'interest-received':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'interest_received')
            self.interest_received.append(fval_)
        elif nodeName_ == 'principal-outstanding':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'principal_outstanding')
            self.principal_outstanding.append(fval_)
        elif nodeName_ == 'principal-arrears':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'principal_arrears')
            self.principal_arrears.append(fval_)
        elif nodeName_ == 'interest-arrears':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'interest_arrears')
            self.interest_arrears.append(fval_)
        else:
            obj_ = self.gds_build_any(child_, 'loan-statusType')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class loan_statusType


class forecastType(GeneratedsSuper):
    """The calendar year that the forward spend covers"""
    subclass = None
    superclass = None
    def __init__(self, currency=None, value_date=None, year=None, valueOf_=None):
        self.currency = _cast(None, currency)
        self.value_date = _cast(None, value_date)
        self.year = _cast(float, year)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if forecastType.subclass:
            return forecastType.subclass(*args_, **kwargs_)
        else:
            return forecastType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_value_date(self): return self.value_date
    def set_value_date(self, value_date): self.value_date = value_date
    def get_year(self): return self.year
    def set_year(self, year): self.year = year
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='forecastType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='forecastType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='forecastType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='forecastType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            outfile.write(' currency=%s' % (self.gds_format_string(quote_attrib(self.currency).encode(ExternalEncoding), input_name='currency'), ))
        if self.value_date is not None and 'value_date' not in already_processed:
            already_processed.add('value_date')
            outfile.write(' value-date=%s' % (self.gds_format_string(quote_attrib(self.value_date).encode(ExternalEncoding), input_name='value-date'), ))
        if self.year is not None and 'year' not in already_processed:
            already_processed.add('year')
            outfile.write(' year="%s"' % self.gds_format_float(self.year, input_name='year'))
    def exportChildren(self, outfile, level, namespace_='', name_='forecastType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='forecastType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            showIndent(outfile, level)
            outfile.write('currency="%s",\n' % (self.currency,))
        if self.value_date is not None and 'value_date' not in already_processed:
            already_processed.add('value_date')
            showIndent(outfile, level)
            outfile.write('value_date="%s",\n' % (self.value_date,))
        if self.year is not None and 'year' not in already_processed:
            already_processed.add('year')
            showIndent(outfile, level)
            outfile.write('year=%f,\n' % (self.year,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('currency', node)
        if value is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            self.currency = value
        value = find_attr_value_('value-date', node)
        if value is not None and 'value-date' not in already_processed:
            already_processed.add('value-date')
            self.value_date = value
        value = find_attr_value_('year', node)
        if value is not None and 'year' not in already_processed:
            already_processed.add('year')
            try:
                self.year = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (year): %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class forecastType


GDSClassesMapping = {
    'comment': textType,
    'person-name': textType,
    'default-tied-status': codeReqType,
    'telephone': telephoneType,
    'repayment-plan': codeType,
    'budget-item': budget_itemType,
    'repayment-first-date': dateType,
    'period-start': dateType,
    'loan-status': loan_statusType,
    'transaction-date': transaction_dateType,
    'forecast': forecastType,
    'loan-terms': loan_termsType,
    'category': codeReqType,
    'indicator': indicatorType,
    'aid-type': codeReqType,
    'baseline': baselineType,
    'receiver-org': receiver_orgType,
    'title': textType,
    'period-end': dateType,
    'organisation': textType,
    'aidtype-flag': aidtype_flagType,
    'coordinates': coordinatesType,
    'finance-type': codeReqType,
    'repayment-type': codeType,
    'commitment-date': dateType,
    'administrative': administrativeType,
    'email': plainType,
    'flow-type': codeReqType,
    'description': textType,
    'repayment-final-date': dateType,
    'disbursement-channel': codeReqType,
    'gazetteer-entry': gazetteer_entryType,
    'language': codeType,
    'collaboration-type': codeReqType,
    'default-finance-type': codeReqType,
    'job-title': textType,
    'default-aid-type': codeReqType,
    'transaction-type': codeReqType,
    'condition': conditionType,
    'target': targetType,
    'activity-scope': codeType,
    'mailing-address': mailing_addressType,
    'actual': actualType,
    'name': textType,
    'provider-org': provider_orgType,
    'value': currencyType,
    'tied-status': codeReqType,
    'period': periodType,
    'location-type': codeReqType,
    'activity-status': codeType,
    'default-flow-type': codeReqType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'iati-activities'
        rootClass = iati_activities
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'iati-activities'
        rootClass = iati_activities
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    roots = get_root_tag(rootNode)
    rootClass = roots[1]
    if rootClass is None:
        rootClass = iati_activities
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_="iati-activities",
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'iati-activities'
        rootClass = iati_activities
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from gendstest import *\n\n')
        sys.stdout.write('import gendstest as model_\n\n')
        sys.stdout.write('rootObj = model_.rootTag(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "activity_date",
    "activity_website",
    "actualType",
    "administrativeType",
    "aidtype_flagType",
    "baselineType",
    "budget",
    "budget_itemType",
    "capital_spend",
    "codeReqType",
    "codeType",
    "conditionType",
    "conditions",
    "contact_info",
    "coordinatesType",
    "country_budget_items",
    "crs_add",
    "currencyType",
    "dateReqType",
    "dateType",
    "description",
    "document_link",
    "forecastType",
    "fss",
    "gazetteer_entryType",
    "iati_activities",
    "iati_activity",
    "iati_identifier",
    "indicatorOutcomeType",
    "indicatorType",
    "legacy_data",
    "loan_statusType",
    "loan_termsType",
    "location",
    "mailing_addressType",
    "other_identifier",
    "participating_org",
    "periodType",
    "plainType",
    "planned_disbursement",
    "policy_marker",
    "provider_orgType",
    "receiver_orgType",
    "recipient_country",
    "recipient_region",
    "refReqType",
    "refType",
    "related_activity",
    "reporting_org",
    "result",
    "sector",
    "targetType",
    "telephoneType",
    "textType",
    "transaction",
    "transaction_dateType"
]
